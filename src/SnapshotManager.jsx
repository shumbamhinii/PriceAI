import React, { useState, useEffect, useCallback } from 'react';
import {
    Box, Button, TextField, Typography, List, ListItem, ListItemText,
    ListItemSecondaryAction, IconButton, Dialog, DialogTitle, DialogContent,
    DialogActions, CircularProgress, Alert, Grid, Card, CardContent, Divider,
    MenuItem, Select, FormControl, InputLabel // Added for dropdowns
} from '@mui/material';
import SaveIcon from '@mui/icons-material/Save';
import FolderOpenIcon from '@mui/icons-material/FolderOpen';
import DeleteIcon from '@mui/icons-material/Delete';
import ClearIcon from '@mui/icons-material/Clear';
import GppGoodIcon from '@mui/icons-material/GppGood'; // New icon for "Use for Quotations"
import axios from 'axios';
import { useNavigate } from 'react-router-dom';
const API_BASE_URL = 'https://priceaibback.onrender.com';

// Helper function to calculate derived pricing metrics from raw snapshot data
// IMPORTANT: This function is primarily for DISPLAYING comparison data within SnapshotManager.
// The primary calculation logic for the main app should remain in PricingPage.jsx's calculatePrices.
const calculateSnapshotPrices = (snapshotData) => {
        // State for snapshot chosen for quotations
        //const [selectedQuotationSnapshotId, setSelectedQuotationSnapshotId] = useState('');
    
        //const navigate = useNavigate(); // Initialize useNavigate hook
    const { total_cost, use_margin, target_profit, target_margin, use_breakdown, products, expenses } = snapshotData;

    // Ensure total_cost is a number
    const safeTotalCost = parseFloat(total_cost) || 0;

    const actualCost = use_breakdown
        ? expenses.reduce((sum, c) => sum + (parseFloat(c.amount) || 0), 0)
        : safeTotalCost;

    const totalVariableCosts = products.reduce((sum, product) => {
        return sum + (parseFloat(product.cost_per_unit) * parseFloat(product.expected_units));
    }, 0);

    const overallTotalCostForRevenueCalculation = actualCost + totalVariableCosts;

    let totalRevenueValue = 0;
    let calculatedProfit = 0;

    if (use_margin) {
        const safeTargetMargin = parseFloat(target_margin) || 0;
        if (safeTargetMargin >= 100) {
            totalRevenueValue = 0;
            calculatedProfit = 0;
        } else {
            totalRevenueValue = overallTotalCostForRevenueCalculation / (1 - safeTargetMargin / 100);
            calculatedProfit = totalRevenueValue - overallTotalCostForRevenueCalculation;
        }
    } else {
        const safeTargetProfit = parseFloat(target_profit) || 0;
        calculatedProfit = safeTargetProfit;
        totalRevenueValue = overallTotalCostForRevenueCalculation + safeTargetProfit;
    }

    // --- Start of Cost-Plus / Percentage specific calculation for comparison display ---
    const percentageBasedProducts = products.filter(p => p.calculation_method === 'percentage');
    const costPlusBasedProducts = products.filter(p => p.calculation_method === 'cost-plus');

    // Calculate fixed cost allocated to percentage-based products based on their % revenue share
    // This part assumes that the percentage values stored in snapshots are already 0-1 (as saved)
    const fixedCostAllocatedToPercentageProducts = percentageBasedProducts.reduce((sum, p) => {
        // Need to know what total revenue percentage these products make up to allocate fixed cost
        // If snapshot data only has individual product revenue_percentage, we assume those are already
        // ratios relative to total revenue.
        const productExpectedRevenue = (parseFloat(p.revenue_percentage) || 0) * totalRevenueValue;
        return sum + ((productExpectedRevenue / totalRevenueValue) * actualCost); // Ratio of their expected revenue to total revenue, applied to total fixed cost
    }, 0);


    // Remaining fixed costs to be covered by cost-plus products
    const fixedCostAllocatedToCostPlusProducts = actualCost - fixedCostAllocatedToPercentageProducts;

    // Calculate the profit generated by percentage-based products (based on their revenue share of overall target profit)
    const profitFromPercentageProducts = percentageBasedProducts.reduce((sum, p) => {
        const productExpectedRevenue = (parseFloat(p.revenue_percentage) || 0) * totalRevenueValue;
        const productVariableCost = (parseFloat(p.cost_per_unit) || 0) * (parseFloat(p.expected_units) || 0);
        const productAllocatedFixedCost = ((productExpectedRevenue / totalRevenueValue) * actualCost); // Re-use the fixed cost allocation logic
        return sum + (productExpectedRevenue - productVariableCost - productAllocatedFixedCost);
    }, 0);

    // The remaining profit that MUST be covered by cost-plus products to hit the overall target profit
    const profitNeededFromCostPlusProducts = calculatedProfit - profitFromPercentageProducts;

    // Total expected units from ALL cost-plus products
    const totalExpectedUnitsCostPlus = costPlusBasedProducts.reduce((sum, p) => sum + (parseFloat(p.expected_units) || 0), 0);


    const calculatedProducts = products.map((product) => {
        const safeExpectedUnits = parseFloat(product.expected_units) > 0 ? parseFloat(product.expected_units) : 1;
        const safeCostPerUnit = parseFloat(product.cost_per_unit) || 0;
        const calculationMethod = product.calculation_method || 'percentage'; // Default to percentage if not present

        let suggestedPrice = 0;
        let percentageRevenue = 0; // This will be the actual revenue percentage for the product
        let suggestedProfitPerUnit = 0;

        if (calculationMethod === 'percentage') {
            const safeRevenuePercentage = parseFloat(product.revenue_percentage) || 0; // Already 0-1 from saved data
            const revenueShare = safeRevenuePercentage * totalRevenueValue;
            suggestedPrice = safeExpectedUnits > 0 ? (revenueShare / safeExpectedUnits) : 0;
            suggestedPrice = Math.round(suggestedPrice * 100) / 100;

            const productRevenue = suggestedPrice * safeExpectedUnits;
            const productVariableCost = safeCostPerUnit * safeExpectedUnits;
            const productAllocatedFixedCost = (productRevenue / totalRevenueValue) * actualCost; // Fixed cost allocated based on its calculated revenue share
            const productProfit = productRevenue - productVariableCost - productAllocatedFixedCost;
            percentageRevenue = productRevenue > 0 ? (productProfit / productRevenue) * 100 : 0; // Actual profit margin for this product
            suggestedProfitPerUnit = safeExpectedUnits > 0 ? productProfit / safeExpectedUnits : 0;

        } else { // 'cost-plus' method
            let profitContributionPerUnit = 0;
            let fixedCostContributionPerUnit = 0;

            if (totalExpectedUnitsCostPlus > 0) {
                profitContributionPerUnit = profitNeededFromCostPlusProducts / totalExpectedUnitsCostPlus;
                fixedCostContributionPerUnit = fixedCostAllocatedToCostPlusProducts / totalExpectedUnitsCostPlus;
            } else if (costPlusBasedProducts.length === 1 && safeExpectedUnits > 0) {
                     // Special case: if only one cost-plus product, it covers all remaining fixed and profit
                     profitContributionPerUnit = profitNeededFromCostPlusProducts; // This should be total profit needed from this product
                     fixedCostContributionPerUnit = fixedCostAllocatedToCostPlusProducts; // Total fixed cost needed from this product
                     profitContributionPerUnit = profitContributionPerUnit / safeExpectedUnits; // per unit
                     fixedCostContributionPerUnit = fixedCostContributionPerUnit / safeExpectedUnits; // per unit
            }

            suggestedProfitPerUnit = profitContributionPerUnit + fixedCostContributionPerUnit;
            suggestedPrice = safeCostPerUnit + suggestedProfitPerUnit;
            suggestedPrice = Math.round(suggestedPrice * 100) / 100;

            const productRevenue = suggestedPrice * safeExpectedUnits;
            const productTotalCost = (safeCostPerUnit * safeExpectedUnits) + (fixedCostContributionPerUnit * safeExpectedUnits);
            percentageRevenue = productRevenue > 0 ? ((productRevenue - productTotalCost) / productRevenue) * 100 : 0;
        }

        return {
            name: product.name,
            // For display, 'percentage' is only relevant for percentage-based products
            percentage: calculationMethod === 'percentage' ? (parseFloat(product.revenue_percentage) || 0) * 100 : 0,
            expectedUnits: parseFloat(product.expected_units) || 0,
            costPerUnit: safeCostPerUnit,
            suggestedPrice: suggestedPrice,
            // unitsNeeded is primarily for percentage method; for cost-plus, it's generally expectedUnits
            unitsNeeded: calculationMethod === 'percentage' ? (suggestedPrice > 0 ? Math.ceil((parseFloat(product.revenue_percentage) || 0) * totalRevenueValue / suggestedPrice) : 0) : product.expected_units,
            percentageRevenue: percentageRevenue, // This is the actual calculated profit margin percentage for the product
            calculationMethod: calculationMethod,
            suggestedProfit: suggestedProfitPerUnit, // The per-unit profit, crucial for cost-plus products
        };
    });

    return {
        actualCost: parseFloat(actualCost) || 0,
        totalRevenue: parseFloat(totalRevenueValue) || 0,
        calculatedProfit: parseFloat(calculatedProfit) || 0,
        calculatedProducts,
        inputs: snapshotData // Keep original inputs for display
    };
};


const SnapshotManager = ({
    loading,
    setLoading,
    setError,
    setSuccessMessage,
    currentPricingState,
    onSnapshotLoaded,
    onCalculatePrices, // Added to trigger recalculation in parent after loading
    setActiveTab, // To switch tabs after loading
    onUseForQuotations // NEW PROP: Callback to pass snapshot data for quotations
}) => {
    const [snapshotName, setSnapshotName] = useState('');
    const [savedSnapshots, setSavedSnapshots] = useState([]);
    const [openLoadDialog, setOpenLoadDialog] = useState(false);
    const [openDeleteDialog, setOpenDeleteDialog] = useState(false);
    const [snapshotToDelete, setSnapshotToDelete] = useState(null);
    const [selectedQuotationSnapshotId, setSelectedQuotationSnapshotId] = useState(''); // NEW STATE for quotation selection
       // const [selectedQuotationSnapshotId, setSelectedQuotationSnapshotId] = useState('');
    
        const navigate = useNavigate(); // Initialize useNavigate hook
    // New state for comparison feature
    const [selectedComparisonSnapshot1Id, setSelectedComparisonSnapshot1Id] = useState('');
    const [selectedComparisonSnapshot2Id, setSelectedComparisonSnapshot2Id] = useState('');
    const [comparisonSnapshot1Data, setComparisonSnapshot1Data] = useState(null);
    const [comparisonResults1, setComparisonResults1] = useState(null);
    const [comparisonSnapshot2Data, setComparisonSnapshot2Data] = useState(null);
    const [comparisonResults2, setComparisonResults2] = useState(null);
    const [comparisonLoading, setComparisonLoading] = useState(false);


    const fetchSnapshots = useCallback(async () => {
        setLoading(true);
        setError('');
        try {
            const response = await axios.get(`${API_BASE_URL}/api/snapshots`);
            setSavedSnapshots(response.data);
        } catch (err) {
            console.error('Error fetching snapshots:', err.response?.data?.message || err.message);
            setError(`Failed to fetch snapshots: ${err.response?.data?.message || err.message}`);
        } finally {
            setLoading(false);
        }
    }, [setLoading, setError]);

    useEffect(() => {
        fetchSnapshots();
    }, [fetchSnapshots]);


    const handleSaveSnapshot = async () => {
        if (!snapshotName.trim()) {
            setError('Please enter a name for the snapshot.');
            return;
        }
        setLoading(true);
        setError('');
        setSuccessMessage('');

        const snapshotData = {
            name: snapshotName,
            total_cost: parseFloat(currentPricingState.totalCost) || 0,
            use_margin: currentPricingState.useMargin,
            target_profit: parseFloat(currentPricingState.targetProfit) || 0,
            target_margin: parseFloat(currentPricingState.targetMargin) || 0,
            use_breakdown: currentPricingState.useBreakdown,
            competitor_prices: currentPricingState.competitorPrices || {},
            products: currentPricingState.products.map(p => ({
                name: p.name,
                // Save based on calculationMethod:
                // For 'percentage', save revenue_percentage (0-1)
                // For 'cost-plus', this field is not directly used for input, so save 0.
                revenue_percentage: p.calculationMethod === 'percentage' ? (parseFloat(p.percentage) / 100) || 0 : 0,
                expected_units: parseFloat(p.expectedUnits) || 0,
                cost_per_unit: parseFloat(p.costPerUnit) || 0,
                calculation_method: p.calculationMethod, // Save the calculation method
             orbital: p.orbital || 0, // Ensure all fields are saved correctly
            })),
            expenses: currentPricingState.useBreakdown ? currentPricingState.individualCosts.map(exp => ({
                ...exp,
                amount: parseFloat(exp.amount) || 0
            })) : [],
        };

        try {
            await axios.post(`${API_BASE_URL}/api/snapshots`, snapshotData);
            setSuccessMessage(`Snapshot "${snapshotName}" saved successfully!`);
            setSnapshotName('');
            fetchSnapshots(); // Refresh the list of saved snapshots
        } catch (err) {
            console.error('Error saving snapshot:', err.response?.data?.message || err.message);
            setError(`Failed to save snapshot: ${err.response?.data?.message || err.message}`);
        } finally {
            setLoading(false);
        }
    };

    const handleLoadSnapshot = async (id) => {
        setLoading(true);
        setError('');
        setSuccessMessage('');
        try {
            const response = await axios.get(`${API_BASE_URL}/api/snapshots/${id}`);
            const snapshot = response.data.snapshot;
            const products = response.data.products.map(p => {
                const loadedPercentage = (parseFloat(p.revenue_percentage) || 0) * 100; // Convert to 0-100 for frontend

                return {
                    name: p.name,
                    percentage: loadedPercentage, // This is for percentage-based input
                    expectedUnits: parseFloat(p.expected_units) || 0,
                    costPerUnit: parseFloat(p.cost_per_unit) || 0,
                    calculationMethod: p.calculation_method || 'cost-plus', // Crucial: load the method
                    orbital: parseFloat(p.orbital) || 0, // Load orbital
                    // These fields will be recalculated by PricingPage after load
                    suggestedProfit: 0,
                    price: 0,
                    unitsNeeded: 0,
                    expected_units: 0,
                    cost_per_unit:0,
                    calculation_method: p.calculationMethod,
                    percentageRevenue: 0,

                };
            });
            const expenses = (response.data.expenses || []).map(exp => ({
                ...exp,
                amount: parseFloat(exp.amount) || 0
            }));

            onSnapshotLoaded({
                name: snapshot.name,
                totalCost: parseFloat(snapshot.total_cost) || 0,
                useMargin: snapshot.use_margin,
                targetProfit: parseFloat(snapshot.target_profit) || 0,
                targetMargin: parseFloat(snapshot.target_margin) || 0,
                useBreakdown: snapshot.use_breakdown,
                individualCosts: expenses,
                products: products,
                competitorPrices: snapshot.competitor_prices || {},
            });
            setSuccessMessage(`Snapshot "${snapshot.name}" loaded successfully!`);
            setOpenLoadDialog(false);
            if (onCalculatePrices) {
                onCalculatePrices(); // Trigger price recalculation in parent's PricingPage
            }
            if (setActiveTab) {
                setActiveTab(0); // Switch to Setup tab after loading a snapshot
            }
        } catch (err) {
            console.error('Error loading snapshot:', err.response?.data?.message || err.message);
            setError(`Failed to load snapshot: ${err.response?.data?.message || err.message}`);
        } finally {
            setLoading(false);
        }
    };

    const handleDeleteSnapshot = async () => {
        if (!snapshotToDelete) return;

        setLoading(true);
        setError('');
        setSuccessMessage('');
        try {
            await axios.delete(`${API_BASE_URL}/api/snapshots/${snapshotToDelete.id}`);
            setSuccessMessage(`Snapshot "${snapshotToDelete.name}" deleted successfully!`);
            fetchSnapshots(); // Refresh list
            // If deleted snapshot was part of comparison or quotation, clear it
            if (selectedComparisonSnapshot1Id === snapshotToDelete.id) {
                setSelectedComparisonSnapshot1Id('');
                setComparisonSnapshot1Data(null);
                setComparisonResults1(null);
            }
            if (selectedComparisonSnapshot2Id === snapshotToDelete.id) {
                setSelectedComparisonSnapshot2Id('');
                setComparisonSnapshot2Data(null);
                setComparisonResults2(null);
            }
            if (selectedQuotationSnapshotId === snapshotToDelete.id) { // NEW: Clear if deleted
                setSelectedQuotationSnapshotId('');
                onUseForQuotations(null); // Notify parent that the selected quotation snapshot is gone
            }
        } catch (err) {
            console.error('Error deleting snapshot:', err.response?.data?.message || err.message);
            setError(`Failed to delete snapshot: ${err.response?.data?.message || err.message}`);
        } finally {
            setLoading(false);
            setOpenDeleteDialog(false);
            setSnapshotToDelete(null);
        }
    };

      // New handler for selecting snapshot for quotations
    const handleSelectQuotationSnapshot = useCallback(async (snapshotId) => {
        setSelectedQuotationSnapshotId(snapshotId); // Set the ID first
        setLoading(true);
        setError('');
        setSuccessMessage('');

        if (!snapshotId) {
            // If clearing selection, just reset and return
            setLoading(false);
            setSuccessMessage('Quotation snapshot selection cleared.');
            navigate('/qoutes', { state: { products: [] } }); // Navigate to quotations page with empty products
            return;
        }

        try {
            const response = await axios.get(`${API_BASE_URL}/api/snapshots/${snapshotId}`);
            const fullSnapshotData = response.data.snapshot;
            const products = response.data.products.map(p => ({
                ...p,
                revenue_percentage: parseFloat(p.revenue_percentage) || 0,
                expected_units: parseFloat(p.expected_units) || 0,
                cost_per_unit: parseFloat(p.cost_per_unit) || 0,
                calculation_method: p.calculation_method || 'cost-plus',
                orbital: parseFloat(p.orbital) || 0,
            }));
            const expenses = (response.data.expenses || []).map(exp => ({
                ...exp,
                amount: parseFloat(exp.amount) || 0
            }));

            const combinedSnapshotData = {
                ...fullSnapshotData,
                total_cost: parseFloat(fullSnapshotData.total_cost) || 0,
                target_profit: parseFloat(fullSnapshotData.target_profit) || 0,
                target_margin: parseFloat(fullSnapshotData.target_margin) || 0,
                products,
                expenses
            };

            // Calculate the prices for these products using your existing calculation logic
            const calculatedResults = calculateSnapshotPrices(combinedSnapshotData);

            setSuccessMessage(`Snapshot "${combinedSnapshotData.name}" selected for quotations.`);

            // Navigate to the quotations page, passing the calculated products
            navigate('/qoutes', { state: { products: calculatedResults.calculatedProducts, snapshotName: combinedSnapshotData.name } });

        } catch (err) {
            console.error('Error fetching/processing snapshot for quotations:', err.response?.data?.message || err.message);
            setError(`Failed to load snapshot for quotations: ${err.response?.data?.message || err.message}`);
            setSelectedQuotationSnapshotId(''); // Clear selection on error
        } finally {
            setLoading(false);
        }
    }, [setError, setSuccessMessage, navigate]);

    // Comparison Logic (remains largely the same, but includes orbital for display)
    const fetchAndProcessComparisonSnapshot = useCallback(async (snapshotId, setSnapshotData, setComparisonResults, dataIndex) => {
        if (!snapshotId) {
            setSnapshotData(null);
            setComparisonResults(null);
            return;
        }

        setComparisonLoading(true);
        setError('');
        try {
            const response = await axios.get(`${API_BASE_URL}/api/snapshots/${snapshotId}`);
            const fullSnapshotData = response.data.snapshot;
            const products = response.data.products.map(p => ({
                ...p,
                revenue_percentage: parseFloat(p.revenue_percentage) || 0,
                expected_units: parseFloat(p.expected_units) || 0,
                cost_per_unit: parseFloat(p.cost_per_unit) || 0,
                calculation_method: p.calculation_method || 'percentage', // Ensure calculation_method is present
                orbital: parseFloat(p.orbital) || 0, // Include orbital here for comparison display
            }));
            const expenses = (response.data.expenses || []).map(exp => ({
                ...exp,
                amount: parseFloat(exp.amount) || 0
            }));

            // Combine into a single object for calculation
            const combinedSnapshotData = {
                ...fullSnapshotData,
                total_cost: parseFloat(fullSnapshotData.total_cost) || 0,
                target_profit: parseFloat(fullSnapshotData.target_profit) || 0,
                target_margin: parseFloat(fullSnapshotData.target_margin) || 0,
                products,
                expenses
            };

            setSnapshotData(combinedSnapshotData);
            // This is where calculateSnapshotPrices is called with the loaded data
            setComparisonResults(calculateSnapshotPrices(combinedSnapshotData));
            setSuccessMessage(`Snapshot ${dataIndex} loaded for comparison: ${combinedSnapshotData.name}`);
        } catch (err) {
            console.error('Error fetching/processing snapshot for comparison:', err.response?.data?.message || err.message);
            setError(`Failed to load snapshot ${dataIndex} for comparison: ${err.response?.data?.message || err.message}`);
            setSnapshotData(null);
            setComparisonResults(null);
        } finally {
            setComparisonLoading(false);
        }
    }, [setError, setSuccessMessage]);

    useEffect(() => {
        fetchAndProcessComparisonSnapshot(selectedComparisonSnapshot1Id, setComparisonSnapshot1Data, setComparisonResults1, 1);
    }, [selectedComparisonSnapshot1Id, fetchAndProcessComparisonSnapshot]);

    useEffect(() => {
        fetchAndProcessComparisonSnapshot(selectedComparisonSnapshot2Id, setComparisonSnapshot2Data, setComparisonResults2, 2);
    }, [selectedComparisonSnapshot2Id, fetchAndProcessComparisonSnapshot]);

    const clearComparison = () => {
        setSelectedComparisonSnapshot1Id('');
        setSelectedComparisonSnapshot2Id('');
        setComparisonSnapshot1Data(null);
        setComparisonSnapshot2Data(null);
        setComparisonResults1(null);
        setComparisonResults2(null);
        setSuccessMessage('Comparison cleared.');
    };

    const renderComparisonColumn = (title, snapshot, results, id) => {
        if (!snapshot || !results) {
            return (
                <Grid item xs={12} sm={6}>
                    <Card elevation={2} sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                        <CardContent>
                            <Typography variant="h6" align="center" gutterBottom>{title}</Typography>
                            <Box display="flex" justifyContent="center" alignItems="center" height={150}>
                                <Typography color="text.secondary">No snapshot selected</Typography>
                            </Box>
                        </CardContent>
                    </Card>
                </Grid>
            );
        }

        return (
            <Grid item xs={12} sm={6}>
                <Card elevation={2} sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                    <CardContent sx={{ flexGrow: 1 }}>
                        <Typography variant="h6" align="center" gutterBottom>{snapshot.name}</Typography>
                        <Typography variant="caption" color="text.secondary" align="center" display="block" mb={1}>
                            {new Date(snapshot.created_at).toLocaleDateString()}
                        </Typography>
                        <Divider sx={{ my: 2 }} />

                        <Typography variant="subtitle1" fontWeight="bold" mt={2}>Overall Metrics:</Typography>
                        <Typography>Monthly Cost: R{results.actualCost.toFixed(2)}</Typography>
                        <Typography>Target {snapshot.use_margin ? `Margin: ${parseFloat(snapshot.target_margin) || 0}%` : `Profit: R${(parseFloat(snapshot.target_profit) || 0).toFixed(2)}`}</Typography>
                        <Typography>Calculated Profit: R{results.calculatedProfit.toFixed(2)}</Typography>
                        <Typography>Total Revenue: R{results.totalRevenue.toFixed(2)}</Typography>
                        <Typography>Cost Breakdown Used: {snapshot.use_breakdown ? 'Yes' : 'No'}</Typography>

                        {snapshot.use_breakdown && (
                            <Box mt={2}>
                                <Typography variant="subtitle2" fontWeight="bold">Individual Expenses:</Typography>
                                {snapshot.expenses.length > 0 ? (
                                    <List dense disablePadding>
                                        {snapshot.expenses.map((exp, idx) => (
                                            <ListItem key={idx} sx={{ py: 0.2 }}>
                                                <ListItemText primary={`${exp.label}: R${(parseFloat(exp.amount) || 0).toFixed(2)}`} />
                                            </ListItem>
                                        ))}
                                    </List>
                                ) : (
                                    <Typography variant="body2" color="text.secondary">No individual expenses recorded.</Typography>
                                )}
                            </Box>
                        )}

                        {Object.keys(snapshot.competitor_prices || {}).length > 0 && (
                            <Box mt={2}>
                                <Typography variant="subtitle2" fontWeight="bold">Competitor Prices:</Typography>
                                <List dense disablePadding>
                                    {Object.entries(snapshot.competitor_prices).map(([productName, price], idx) => (
                                        <ListItem key={idx} sx={{ py: 0.2 }}>
                                            <ListItemText primary={`${productName}: R${(parseFloat(price) || 0).toFixed(2)}`} />
                                        </ListItem>
                                    ))}
                                </List>
                            </Box>
                        )}

                        <Typography variant="subtitle1" fontWeight="bold" mt={3}>Product Details:</Typography>
                        {results.calculatedProducts.length > 0 ? (
                            results.calculatedProducts.map((product, index) => (
                                <Box key={index} sx={{ mb: 1.5, p: 1.5, border: '1px solid #eee', borderRadius: '8px', backgroundColor: '#f9f9f9' }}>
                                    <Typography variant="body1" fontWeight="bold">{product.name || `Product ${index + 1}`}</Typography>
                                    <Typography variant="body2">
                                        Calculation Method: {product.calculationMethod === 'percentage' ? 'Percentage Revenue' : 'Cost-Plus'}
                                    </Typography>
                                    {/* Display fields based on calculation method */}
                                    {product.calculationMethod === 'percentage' && (
                                        <>
                                            <Typography variant="body2">Revenue Share (Input): {product.percentage.toFixed(2)}%</Typography>
                                            <Typography variant="body2">Calculated Unit Price: R{product.suggestedPrice.toFixed(2)}</Typography>
                                            <Typography variant="body2">Units Needed to Sell: {product.unitsNeeded}</Typography>
                                            <Typography variant="body2">Actual Product Margin: {product.percentageRevenue.toFixed(2)}%</Typography>
                                        </>
                                    )}
                                    {product.calculationMethod === 'cost-plus' && (
                                        <>
                                            <Typography variant="body2">Expected Units: {product.expectedUnits}</Typography>
                                            <Typography variant="body2">Cost Per Unit: R{product.costPerUnit.toFixed(2)}</Typography>
                                            <Typography variant="body2">Calculated Profit Per Unit: R{product.suggestedProfit.toFixed(2)}</Typography>
                                            <Typography variant="body2">Calculated Unit Price: R{product.suggestedPrice.toFixed(2)}</Typography>
                                            <Typography variant="body2">Actual Product Margin: {product.percentageRevenue.toFixed(2)}%</Typography>
                                        </>
                                    )}
                                    {/* Display orbital if it exists and is meaningful */}
                                    {product.orbital > 0 && (
                                        <Typography variant="body2">Orbital: {product.orbital.toFixed(2)}</Typography>
                                    )}
                                </Box>
                            ))
                        ) : (
                            <Typography color="text.secondary">No product data for this snapshot.</Typography>
                        )}
                    </CardContent>
                </Card>
            </Grid>
        );
    };

    const renderComparisonInsights = () => {
        if (!comparisonResults1 || !comparisonResults2 || !comparisonSnapshot1Data || !comparisonSnapshot2Data) {
            return null; // Don't render insights if not both snapshots are loaded
        }

        const s1 = comparisonResults1;
        const s2 = comparisonResults2;
        const s1Name = comparisonSnapshot1Data.name;
        const s2Name = comparisonSnapshot2Data.name;

        const insights = [];

        // 1. Profit Comparison
        if (s1.calculatedProfit > s2.calculatedProfit) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s1Name}</Typography> has a higher calculated profit of R{s1.calculatedProfit.toFixed(2)} compared to R{s2.calculatedProfit.toFixed(2)} from <Typography component="span" fontWeight="bold">{s2Name}</Typography>.
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** If maximizing overall profit is your primary goal, <Typography component="span" fontWeight="bold">{s1Name}</Typography> is the better choice.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        } else if (s2.calculatedProfit > s1.calculatedProfit) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s2Name}</Typography> has a higher calculated profit of R{s2.calculatedProfit.toFixed(2)} compared to R{s1.calculatedProfit.toFixed(2)} from <Typography component="span" fontWeight="bold">{s1Name}</Typography>.
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** For greater profitability, consider strategies aligned with <Typography component="span" fontWeight="bold">{s2Name}</Typography>.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        } else {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            Both snapshots yield a similar calculated profit of R{s1.calculatedProfit.toFixed(2)}.
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** If profit is equal, evaluate other factors like operational cost or unit prices.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        }

        // 2. Revenue Comparison
        if (s1.totalRevenue > s2.totalRevenue) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s1Name}</Typography> projects higher total revenue (R{s1.totalRevenue.toFixed(2)}) than <Typography component="span" fontWeight="bold">{s2Name}</Typography> (R{s2.totalRevenue.toFixed(2)}).
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** <Typography component="span" fontWeight="bold">{s1Name}</Typography> suggests a larger market reach or higher pricing strategy. This is ideal if revenue growth is a key objective, even if profit is similar.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        } else if (s2.totalRevenue > s1.totalRevenue) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s2Name}</Typography> projects higher total revenue (R{s2.totalRevenue.toFixed(2)}) than <Typography component="span" fontWeight="bold">{s1Name}</Typography> (R{s1.totalRevenue.toFixed(2)}).
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** If increasing top-line revenue is crucial, focus on the approach in <Typography component="span" fontWeight="bold">{s2Name}</Typography>.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        } else {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            Both snapshots project similar total revenue (R{s1.totalRevenue.toFixed(2)}).
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** Consider which snapshot achieves this revenue with lower risk or operational complexity.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        }

        // 3. Cost-effectiveness (Revenue per unit of cost)
        const s1CostEffectiveness = s1.totalRevenue / s1.actualCost;
        const s2CostEffectiveness = s2.totalRevenue / s2.actualCost;
        if (s1CostEffectiveness > s2CostEffectiveness) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s1Name}</Typography> is more cost-effective (R{s1CostEffectiveness.toFixed(2)} revenue per R1 cost) than <Typography component="span" fontWeight="bold">{s2Name}</Typography> (R{s2CostEffectiveness.toFixed(2)} revenue per R1 cost).
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** <Typography component="span" fontWeight="bold">{s1Name}</Typography> is more efficient at converting costs into revenue.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        } else if (s2CostEffectiveness > s1CostEffectiveness) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s2Name}</Typography> is more cost-effective (R{s2CostEffectiveness.toFixed(2)} revenue per R1 cost) than <Typography component="span" fontWeight="bold">{s1Name}</Typography> (R{s1CostEffectiveness.toFixed(2)} revenue per R1 cost).
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** <Typography component="span" fontWeight="bold">{s2Name}</Typography> shows better operational efficiency.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        } else {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            Both snapshots show similar cost-effectiveness (R{s1CostEffectiveness.toFixed(2)} revenue per R1 cost).
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** Look for other differentiators or areas for improvement in either model.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        }

        // 4. Product-level comparison (e.g., higher profit products)
        const commonProducts = s1.calculatedProducts.filter(p1 =>
            s2.calculatedProducts.some(p2 => p2.name === p1.name)
        );

        commonProducts.forEach(p1 => {
            const p2 = s2.calculatedProducts.find(prod => prod.name === p1.name);
            if (p2) {
                if (p1.suggestedPrice > p2.suggestedPrice) {
                    insights.push(
                        <ListItem>
                            <ListItemText primary={
                                <Typography variant="body2">
                                    <Typography component="span" fontWeight="bold">{p1.name}</Typography> is priced higher in <Typography component="span" fontWeight="bold">{s1Name}</Typography> (R{p1.suggestedPrice.toFixed(2)}) compared to <Typography component="span" fontWeight="bold">{s2Name}</Typography> (R{p2.suggestedPrice.toFixed(2)}).
                                </Typography>
                            } />
                        </ListItem>
                    );
                } else if (p2.suggestedPrice > p1.suggestedPrice) {
                    insights.push(
                        <ListItem>
                            <ListItemText primary={
                                <Typography variant="body2">
                                    <Typography component="span" fontWeight="bold">{p1.name}</Typography> is priced higher in <Typography component="span" fontWeight="bold">{s2Name}</Typography> (R{p2.suggestedPrice.toFixed(2)}) compared to <Typography component="span" fontWeight="bold">{s1Name}</Typography> (R{p1.suggestedPrice.toFixed(2)}).
                                </Typography>
                            } />
                        </ListItem>
                    );
                }

                if (p1.percentageRevenue > p2.percentageRevenue) {
                    insights.push(
                        <ListItem>
                            <ListItemText primary={
                                <Typography variant="body2">
                                    <Typography component="span" fontWeight="bold">{p1.name}</Typography> yields a higher actual product margin in <Typography component="span" fontWeight="bold">{s1Name}</Typography> ({p1.percentageRevenue.toFixed(2)}%) vs. <Typography component="span" fontWeight="bold">{s2Name}</Typography> ({p2.percentageRevenue.toFixed(2)}%).
                                </Typography>
                            } />
                        </ListItem>
                    );
                } else if (p2.percentageRevenue > p1.percentageRevenue) {
                    insights.push(
                        <ListItem>
                            <ListItemText primary={
                                <Typography variant="body2">
                                    <Typography component="span" fontWeight="bold">{p1.name}</Typography> yields a higher actual product margin in <Typography component="span" fontWeight="bold">{s2Name}</Typography> ({p2.percentageRevenue.toFixed(2)}%) vs. <Typography component="span" fontWeight="bold">{s1Name}</Typography> ({p1.percentageRevenue.toFixed(2)}%).
                                </Typography>
                            } />
                        </ListItem>
                    );
                }
            }
        });

        if (insights.length === 0) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography color="text.secondary">No specific key differences found or products do not overlap significantly.</Typography>
                    } />
                </ListItem>
            );
        }

        return (
            <Box mt={4}>
                <Typography variant="h6" gutterBottom>Comparison Insights</Typography>
                <List dense>
                    {insights}
                </List>
            </Box>
        );
    };


    return (
        <Box sx={{ p: 3 }}>
            {loading && <CircularProgress sx={{ mb: 2 }} />}
            {/* Error and Success Alerts */}
            {setError && <Alert severity="error" sx={{ mb: 2 }}>{setError}</Alert>}
            {setSuccessMessage && <Alert severity="success" sx={{ mb: 2 }}>{setSuccessMessage}</Alert>}

            {/* Save Snapshot Section */}
            <Typography variant="h5" gutterBottom>Manage Pricing Snapshots</Typography>
            <Box sx={{ mb: 4, display: 'flex', alignItems: 'center', gap: 2 }}>
                <TextField
                    label="Snapshot Name"
                    variant="outlined"
                    value={snapshotName}
                    onChange={(e) => setSnapshotName(e.target.value)}
                    sx={{ flexGrow: 1 }}
                    disabled={loading}
                />
                <Button
                    variant="contained"
                    startIcon={<SaveIcon />}
                    onClick={handleSaveSnapshot}
                    disabled={loading || !snapshotName.trim()}
                >
                    Save Current Pricing
                </Button>
                <Button
                    variant="outlined"
                    startIcon={<FolderOpenIcon />}
                    onClick={() => setOpenLoadDialog(true)}
                    disabled={loading || savedSnapshots.length === 0}
                >
                    Load Snapshot
                </Button>
            </Box>

            <Divider sx={{ my: 4 }} />

            {/* New Section: Select Snapshot for Quotations */}
            <Typography variant="h5" gutterBottom>Select Snapshot for Quotations</Typography>
            <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                Choose a saved pricing snapshot to use its product list and calculated prices for generating quotations.
            </Typography>
            <Box sx={{ mb: 4, display: 'flex', alignItems: 'center', gap: 2 }}>
                <FormControl fullWidth disabled={loading || savedSnapshots.length === 0}>
                    <InputLabel id="quotation-snapshot-select-label">Snapshot for Quotations</InputLabel>
                    <Select
                        labelId="quotation-snapshot-select-label"
                        id="quotation-snapshot-select"
                        value={selectedQuotationSnapshotId}
                        label="Snapshot for Quotations"
                        onChange={(e) => handleSelectQuotationSnapshot(e.target.value)}
                    >
                        <MenuItem value="">
                            <em>None Selected</em>
                        </MenuItem>
                        {savedSnapshots.map((snapshot) => (
                            <MenuItem key={snapshot.id} value={snapshot.id}>
                                {snapshot.name} ({new Date(snapshot.created_at).toLocaleDateString()})
                            </MenuItem>
                        ))}
                    </Select>
                </FormControl>
                {selectedQuotationSnapshotId && (
                    <Button
                        variant="outlined"
                        color="error"
                        startIcon={<ClearIcon />}
                        onClick={() => handleSelectQuotationSnapshot('')}
                        disabled={loading}
                    >
                        Clear
                    </Button>
                )}
            </Box>

            <Divider sx={{ my: 4 }} />

            {/* Comparison Section */}
            <Typography variant="h5" gutterBottom>Compare Snapshots</Typography>
            <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                Select two snapshots to compare their overall metrics and product pricing strategies.
            </Typography>
            <Grid container spacing={3} sx={{ mb: 4 }}>
                <Grid item xs={12} sm={6}>
                    <FormControl fullWidth disabled={comparisonLoading || savedSnapshots.length < 1}>
                        <InputLabel id="comparison-snapshot1-select-label">Snapshot 1</InputLabel>
                        <Select
                            labelId="comparison-snapshot1-select-label"
                            id="comparison-snapshot1-select"
                            value={selectedComparisonSnapshot1Id}
                            label="Snapshot 1"
                            onChange={(e) => setSelectedComparisonSnapshot1Id(e.target.value)}
                        >
                            <MenuItem value="">
                                <em>None Selected</em>
                            </MenuItem>
                            {savedSnapshots.map((snapshot) => (
                                <MenuItem key={snapshot.id} value={snapshot.id}>
                                    {snapshot.name} ({new Date(snapshot.created_at).toLocaleDateString()})
                                </MenuItem>
                            ))}
                        </Select>
                    </FormControl>
                </Grid>
                <Grid item xs={12} sm={6}>
                    <FormControl fullWidth disabled={comparisonLoading || savedSnapshots.length < 2}>
                        <InputLabel id="comparison-snapshot2-select-label">Snapshot 2</InputLabel>
                        <Select
                            labelId="comparison-snapshot2-select-label"
                            id="comparison-snapshot2-select"
                            value={selectedComparisonSnapshot2Id}
                            label="Snapshot 2"
                            onChange={(e) => setSelectedComparisonSnapshot2Id(e.target.value)}
                        >
                            <MenuItem value="">
                                <em>None Selected</em>
                            </MenuItem>
                            {savedSnapshots.map((snapshot) => (
                                <MenuItem key={snapshot.id} value={snapshot.id}>
                                    {snapshot.name} ({new Date(snapshot.created_at).toLocaleDateString()})
                                </MenuItem>
                            ))}
                        </Select>
                    </FormControl>
                </Grid>
            </Grid>
            <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 4 }}>
                <Button
                    variant="outlined"
                    color="error"
                    startIcon={<ClearIcon />}
                    onClick={clearComparison}
                    disabled={comparisonLoading || (!selectedComparisonSnapshot1Id && !selectedComparisonSnapshot2Id)}
                >
                    Clear Comparison
                </Button>
            </Box>

            {(selectedComparisonSnapshot1Id || selectedComparisonSnapshot2Id) && (
                <Box mt={4}>
                    <Typography variant="h6" gutterBottom>Comparison Overview</Typography>
                    {comparisonLoading && <CircularProgress />}
                    <Grid container spacing={3}>
                        {renderComparisonColumn("Snapshot 1", comparisonSnapshot1Data, comparisonResults1, 1)}
                        {renderComparisonColumn("Snapshot 2", comparisonSnapshot2Data, comparisonResults2, 2)}
                    </Grid>
                    {renderComparisonInsights()}
                </Box>
            )}


            {/* Load Snapshot Dialog */}
            <Dialog open={openLoadDialog} onClose={() => setOpenLoadDialog(false)} fullWidth maxWidth="sm">
                <DialogTitle>Load Pricing Snapshot</DialogTitle>
                <DialogContent>
                    {loading && <CircularProgress />}
                    {!loading && savedSnapshots.length === 0 && (
                        <Typography>No snapshots saved yet.</Typography>
                    )}
                    <List>
                        {savedSnapshots.map((snapshot) => (
                            <ListItem
                                key={snapshot.id}
                                secondaryAction={
                                    <IconButton
                                        edge="end"
                                        aria-label="delete"
                                        onClick={() => {
                                            setSnapshotToDelete(snapshot);
                                            setOpenDeleteDialog(true);
                                        }}
                                    >
                                        <DeleteIcon />
                                    </IconButton>
                                }
                            >
                                <ListItemText
                                    primary={snapshot.name}
                                    secondary={`Saved on: ${new Date(snapshot.created_at).toLocaleDateString()} at ${new Date(snapshot.created_at).toLocaleTimeString()}`}
                                />
                                <ListItemSecondaryAction>
                                    <Button
                                        variant="outlined"
                                        size="small"
                                        onClick={() => handleLoadSnapshot(snapshot.id)}
                                        disabled={loading}
                                        sx={{ mr: 1 }}
                                    >
                                        Load
                                    </Button>
                                    {/* NEW: Button to use for Quotations directly from Load dialog */}
                                    <Button
                                        variant="contained"
                                        size="small"
                                        startIcon={<GppGoodIcon />}
                                        onClick={() => {
                                            handleSelectQuotationSnapshot(snapshot.id);
                                            setOpenLoadDialog(false); // Close dialog after selection
                                        }}
                                        disabled={loading || selectedQuotationSnapshotId === snapshot.id}
                                    >
                                        Use for Quotations
                                    </Button>
                                </ListItemSecondaryAction>
                            </ListItem>
                        ))}
                    </List>
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setOpenLoadDialog(false)}>Cancel</Button>
                </DialogActions>
            </Dialog>

            {/* Delete Confirmation Dialog */}
            <Dialog open={openDeleteDialog} onClose={() => setOpenDeleteDialog(false)}>
                <DialogTitle>Confirm Delete</DialogTitle>
                <DialogContent>
                    <Typography>Are you sure you want to delete snapshot "{snapshotToDelete?.name}"?</Typography>
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setOpenDeleteDialog(false)} color="primary">
                        Cancel
                    </Button>
                    <Button onClick={handleDeleteSnapshot} color="error" autoFocus>
                        Delete
                    </Button>
                </DialogActions>
            </Dialog>
        </Box>
    );
};

export default SnapshotManager;
