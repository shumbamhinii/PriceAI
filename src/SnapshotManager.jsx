import React, { useState, useEffect, useCallback } from 'react';
import {
    Box, Button, TextField, Typography, List, ListItem, ListItemText,
    ListItemSecondaryAction, IconButton, Dialog, DialogTitle, DialogContent,
    DialogActions,DialogContentText,  Snackbar,
   CircularProgress, Alert, Grid, Card, CardContent, Divider
} from '@mui/material';
import { Paper } from '@mui/material';
import { MenuItem } from '@mui/material';
import SaveIcon from '@mui/icons-material/Save';
import FolderOpenIcon from '@mui/icons-material/FolderOpen';
import DeleteIcon from '@mui/icons-material/Delete';
import ClearIcon from '@mui/icons-material/Clear';
import CheckCircleIcon from '@mui/icons-material/CheckCircle'; // New icon for 'Use for Quotations'
import { useNavigate } from 'react-router-dom'; // Import useNavigate for redirection
import axios from 'axios';

// IMPORTANT: Ensure this matches your backend URL.
// For Render deployment, it should be your Render backend URL, e.g., 'https://priceaibback.onrender.com'
const API_BASE_URL = 'https://priceaibback.onrender.com'; // Changed from localhost for deployment readiness


// Helper function to calculate derived pricing metrics from raw snapshot data
// IMPORTANT: This function is primarily for DISPLAYING comparison data within SnapshotManager.
// The primary calculation logic for the main app should remain in PricingPage.jsx's calculatePrices.
const calculateSnapshotPrices = (snapshotData) => {
    const { total_cost, use_margin, target_profit, target_margin, use_breakdown, products, expenses } = snapshotData;

    // Ensure total_cost is a number
    const safeTotalCost = parseFloat(total_cost) || 0;

    const actualCost = use_breakdown
        ? expenses.reduce((sum, c) => sum + (parseFloat(c.amount) || 0), 0)
        : safeTotalCost;

    const totalVariableCosts = products.reduce((sum, product) => {
        return sum + (parseFloat(product.cost_per_unit) * parseFloat(product.expected_units));
    }, 0);

    const overallTotalCostForRevenueCalculation = actualCost + totalVariableCosts;

    let totalRevenueValue = 0;
    let calculatedProfit = 0;

    if (use_margin) {
        const safeTargetMargin = parseFloat(target_margin) || 0;
        if (safeTargetMargin >= 100) {
            totalRevenueValue = 0;
            calculatedProfit = 0;
        } else {
            totalRevenueValue = overallTotalCostForRevenueCalculation / (1 - safeTargetMargin / 100);
            calculatedProfit = totalRevenueValue - overallTotalCostForRevenueCalculation;
        }
    } else {
        const safeTargetProfit = parseFloat(target_profit) || 0;
        calculatedProfit = safeTargetProfit;
        totalRevenueValue = overallTotalCostForRevenueCalculation + safeTargetProfit;
    }

    // --- Start of Cost-Plus / Percentage specific calculation for comparison display ---
    const percentageBasedProducts = products.filter(p => p.calculation_method === 'percentage');
    const costPlusBasedProducts = products.filter(p => p.calculation_method === 'cost-plus');

    // Calculate fixed cost allocated to percentage-based products based on their % revenue share
    // This part assumes that the percentage values stored in snapshots are already 0-1 (as saved)
    const fixedCostAllocatedToPercentageProducts = percentageBasedProducts.reduce((sum, p) => {
        // Need to know what total revenue percentage these products make up to allocate fixed cost
        // If snapshot data only has individual product revenue_percentage, we assume those are already
        // ratios relative to total revenue.
        const productExpectedRevenue = (parseFloat(p.revenue_percentage) || 0) * totalRevenueValue;
        return sum + ((productExpectedRevenue / totalRevenueValue) * actualCost); // Ratio of their expected revenue to total revenue, applied to total fixed cost
    }, 0);


    // Remaining fixed costs to be covered by cost-plus products
    const fixedCostAllocatedToCostPlusProducts = actualCost - fixedCostAllocatedToPercentageProducts;

    // Calculate the profit generated by percentage-based products (based on their revenue share of overall target profit)
    const profitFromPercentageProducts = percentageBasedProducts.reduce((sum, p) => {
        const productExpectedRevenue = (parseFloat(p.revenue_percentage) || 0) * totalRevenueValue;
        const productVariableCost = (parseFloat(p.cost_per_unit) || 0) * (parseFloat(p.expected_units) || 0);
        const productAllocatedFixedCost = ((productExpectedRevenue / totalRevenueValue) * actualCost); // Re-use the fixed cost allocation logic
        return sum + (productExpectedRevenue - productVariableCost - productAllocatedFixedCost);
    }, 0);

    // The remaining profit that MUST be covered by cost-plus products to hit the overall target profit
    const profitNeededFromCostPlusProducts = calculatedProfit - profitFromPercentageProducts;

    // Total expected units from ALL cost-plus products
    const totalExpectedUnitsCostPlus = costPlusBasedProducts.reduce((sum, p) => sum + (parseFloat(p.expected_units) || 0), 0);


    const calculatedProducts = products.map((product) => {
        const safeExpectedUnits = parseFloat(product.expected_units) > 0 ? parseFloat(product.expected_units) : 1;
        const safeCostPerUnit = parseFloat(product.cost_per_unit) || 0;
        const calculationMethod = product.calculation_method || 'percentage'; // Default to percentage if not present

        let suggestedPrice = 0;
        let percentageRevenue = 0; // This will be the actual revenue percentage for the product
        let suggestedProfitPerUnit = 0;

        if (calculationMethod === 'percentage') {
            const safeRevenuePercentage = parseFloat(product.revenue_percentage) || 0; // Already 0-1 from saved data
            const revenueShare = safeRevenuePercentage * totalRevenueValue;
            suggestedPrice = safeExpectedUnits > 0 ? (revenueShare / safeExpectedUnits) : 0;
            suggestedPrice = Math.round(suggestedPrice * 100) / 100;

            const productRevenue = suggestedPrice * safeExpectedUnits;
            const productVariableCost = safeCostPerUnit * safeExpectedUnits;
            const productAllocatedFixedCost = (productRevenue / totalRevenueValue) * actualCost; // Fixed cost allocated based on its calculated revenue share
            const productProfit = productRevenue - productVariableCost - productAllocatedFixedCost;
            percentageRevenue = productRevenue > 0 ? (productProfit / productRevenue) * 100 : 0; // Actual profit margin for this product
            suggestedProfitPerUnit = safeExpectedUnits > 0 ? productProfit / safeExpectedUnits : 0;

        } else { // 'cost-plus' method
            let profitContributionPerUnit = 0;
            let fixedCostContributionPerUnit = 0;

            if (totalExpectedUnitsCostPlus > 0) {
                profitContributionPerUnit = profitNeededFromCostPlusProducts / totalExpectedUnitsCostPlus;
                fixedCostContributionPerUnit = fixedCostAllocatedToCostPlusProducts / totalExpectedUnitsCostPlus;
            } else if (costPlusBasedProducts.length === 1 && safeExpectedUnits > 0) {
                   // Special case: if only one cost-plus product, it covers all remaining fixed and profit
                   profitContributionPerUnit = profitNeededFromCostPlusProducts; // This should be total profit needed from this product
                   fixedCostContributionPerUnit = fixedCostAllocatedToCostPlusProducts; // Total fixed cost needed from this product
                   profitContributionPerUnit = profitContributionPerUnit / safeExpectedUnits; // per unit
                   fixedCostContributionPerUnit = fixedCostContributionPerUnit / safeExpectedUnits; // per unit
            }

            suggestedProfitPerUnit = profitContributionPerUnit + fixedCostContributionPerUnit;
            suggestedPrice = safeCostPerUnit + suggestedProfitPerUnit;
            suggestedPrice = Math.round(suggestedPrice * 100) / 100;

            const productRevenue = suggestedPrice * safeExpectedUnits;
            const productTotalCost = (safeCostPerUnit * safeExpectedUnits) + (fixedCostContributionPerUnit * safeExpectedUnits);
            percentageRevenue = productRevenue > 0 ? ((productRevenue - productTotalCost) / productRevenue) * 100 : 0;
        }

        return {
            name: product.name,
            // For display, 'percentage' is only relevant for percentage-based products
            percentage: calculationMethod === 'percentage' ? (parseFloat(product.revenue_percentage) || 0) * 100 : 0,
            expectedUnits: parseFloat(product.expected_units) || 0,
            costPerUnit: safeCostPerUnit,
            suggestedPrice: suggestedPrice,
            // unitsNeeded is primarily for percentage method; for cost-plus, it's generally expectedUnits
            unitsNeeded: calculationMethod === 'percentage' ? (suggestedPrice > 0 ? Math.ceil((parseFloat(product.revenue_percentage) || 0) * totalRevenueValue / suggestedPrice) : 0) : product.expected_units,
            percentageRevenue: percentageRevenue, // This is the actual calculated profit margin percentage for the product
            calculationMethod: calculationMethod,
            suggestedProfit: suggestedProfitPerUnit, // The per-unit profit, crucial for cost-plus products
        };
    });

    return {
        actualCost: parseFloat(actualCost) || 0,
        totalRevenue: parseFloat(totalRevenueValue) || 0,
        calculatedProfit: parseFloat(calculatedProfit) || 0,
        calculatedProducts,
        inputs: snapshotData // Keep original inputs for display
    };
};


const SnapshotManager = ({
    loading,
    setLoading,
    setError,
    setSuccessMessage,
    currentPricingState,
    onSnapshotLoaded,
    onCalculatePrices, // Added to trigger recalculation in parent after loading
    setActiveTab // To switch tabs after loading
}) => {
    const [snapshotName, setSnapshotName] = useState('');
    const [savedSnapshots, setSavedSnapshots] = useState([]);
    const [openLoadDialog, setOpenLoadDialog] = useState(false);
    const [openDeleteDialog, setOpenDeleteDialog] = useState(false);
    const [snapshotToDelete, setSnapshotToDelete] = useState(null);
    const navigate = useNavigate(); // Hook for navigation

    // New state for comparison feature
    const [selectedComparisonSnapshot1Id, setSelectedComparisonSnapshot1Id] = useState('');
    const [selectedComparisonSnapshot2Id, setSelectedComparisonSnapshot2Id] = useState('');
    const [comparisonSnapshot1Data, setComparisonSnapshot1Data] = useState(null);
    const [comparisonResults1, setComparisonResults1] = useState(null);
    const [comparisonSnapshot2Data, setComparisonSnapshot2Data] = useState(null);
    const [comparisonResults2, setComparisonResults2] = useState(null);
    const [comparisonLoading, setComparisonLoading] = useState(false);
  const [openConfirmDialog, setOpenConfirmDialog] = useState(false);
  const [selectedSnapshotForQuote, setSelectedSnapshotForQuote] = useState({ id: null, name: '' });
  const [openSnackbar, setOpenSnackbar] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState('');

    const fetchSnapshots = useCallback(async () => {
        setLoading(true);
        setError('');
        try {
            const response = await axios.get(`${API_BASE_URL}/api/snapshots`);
            setSavedSnapshots(response.data);
        } catch (err) {
            console.error('Error fetching snapshots:', err.response?.data?.message || err.message);
            setError(`Failed to fetch snapshots: ${err.response?.data?.message || err.message}`);
        } finally {
            setLoading(false);
        }
    }, [setLoading, setError]);

    useEffect(() => {
        fetchSnapshots();
    }, [fetchSnapshots]);


    const handleSaveSnapshot = async () => {
        if (!snapshotName.trim()) {
            setError('Please enter a name for the snapshot.');
            return;
        }
        setLoading(true);
        setError('');
        setSuccessMessage('');

        const snapshotData = {
            name: snapshotName,
            total_cost: parseFloat(currentPricingState.totalCost) || 0,
            use_margin: currentPricingState.useMargin,
            target_profit: parseFloat(currentPricingState.targetProfit) || 0,
            target_margin: parseFloat(currentPricingState.targetMargin) || 0,
            use_breakdown: currentPricingState.useBreakdown,
            competitor_prices: currentPricingState.competitorPrices || {},
            products: currentPricingState.products.map(p => ({
                name: p.name,
                // Save based on calculationMethod:
                // For 'percentage', save revenue_percentage (0-1)
                // For 'cost-plus', this field is not directly used for input, so save 0.
                revenue_percentage: p.calculationMethod === 'percentage' ? (parseFloat(p.percentage) / 100) || 0 : 0,
                expected_units: parseFloat(p.expectedUnits) || 0,
                cost_per_unit: parseFloat(p.costPerUnit) || 0,
                calculation_method: p.calculationMethod, // Save the calculation method
            })),
            expenses: currentPricingState.useBreakdown ? currentPricingState.individualCosts.map(exp => ({
                ...exp,
                amount: parseFloat(exp.amount) || 0
            })) : [],
        };

        try {
            await axios.post(`${API_BASE_URL}/api/snapshots`, snapshotData);
            setSuccessMessage(`Snapshot "${snapshotName}" saved successfully!`);
            setSnapshotName('');
            fetchSnapshots(); // Refresh the list of saved snapshots
        } catch (err) {
            console.error('Error saving snapshot:', err.response?.data?.message || err.message);
            setError(`Failed to save snapshot: ${err.response?.data?.message || err.message}`);
        } finally {
            setLoading(false);
        }
    };

    const handleLoadSnapshot = async (id) => {
        setLoading(true);
        setError('');
        setSuccessMessage('');
        try {
            const response = await axios.get(`${API_BASE_URL}/api/snapshots/${id}`);
            const snapshot = response.data.snapshot;
            const products = response.data.products.map(p => {
                const loadedPercentage = (parseFloat(p.revenue_percentage) || 0) * 100; // Convert to 0-100 for frontend

                return {
                    name: p.name,
                    percentage: loadedPercentage, // This is for percentage-based input
                    expectedUnits: parseFloat(p.expected_units) || 0,
                    costPerUnit: parseFloat(p.cost_per_unit) || 0,
                    calculationMethod: p.calculation_method || 'percentage', // Crucial: load the method
                    // These fields will be recalculated by PricingPage after load
                    suggestedProfit: 0,
                    price: 0,
                    unitsNeeded: 0,
                    percentageRevenue: 0,
                };
            });
            const expenses = (response.data.expenses || []).map(exp => ({
                ...exp,
                amount: parseFloat(exp.amount) || 0
            }));

            onSnapshotLoaded({
                name: snapshot.name,
                totalCost: parseFloat(snapshot.total_cost) || 0,
                useMargin: snapshot.use_margin,
                targetProfit: parseFloat(snapshot.target_profit) || 0,
                targetMargin: parseFloat(snapshot.target_margin) || 0,
                useBreakdown: snapshot.use_breakdown,
                individualCosts: expenses,
                products: products,
                competitorPrices: snapshot.competitor_prices || {},
            });
            setSuccessMessage(`Snapshot "${snapshot.name}" loaded successfully!`);
            setOpenLoadDialog(false);
            if (onCalculatePrices) {
                onCalculatePrices(); // Trigger price recalculation in parent's PricingPage
            }
            if (setActiveTab) {
                setActiveTab(0); // Switch to Setup tab after loading a snapshot
            }
        } catch (err) {
            console.error('Error loading snapshot:', err.response?.data?.message || err.message);
            setError(`Failed to load snapshot: ${err.response?.data?.message || err.message}`);
        } finally {
            setLoading(false);
        }
    };

    const handleDeleteSnapshot = async () => {
        if (!snapshotToDelete) return;

        setLoading(true);
        setError('');
        setSuccessMessage('');
        try {
            await axios.delete(`${API_BASE_URL}/api/snapshots/${snapshotToDelete.id}`);
            setSuccessMessage(`Snapshot "${snapshotToDelete.name}" deleted successfully!`);
            fetchSnapshots(); // Refresh list
            // If deleted snapshot was part of comparison, clear it
            if (selectedComparisonSnapshot1Id === snapshotToDelete.id) {
                setSelectedComparisonSnapshot1Id('');
                setComparisonSnapshot1Data(null);
                setComparisonResults1(null);
            }
            if (selectedComparisonSnapshot2Id === snapshotToDelete.id) {
                setSelectedComparisonSnapshot2Id('');
                setComparisonSnapshot2Data(null);
                setComparisonResults2(null);
            }
        } catch (err) {
            console.error('Error deleting snapshot:', err.response?.data?.message || err.message);
            setError(`Failed to delete snapshot: ${err.response?.data?.message || err.message}`);
        } finally {
            setLoading(false);
            setOpenDeleteDialog(false);
            setSnapshotToDelete(null);
        }
    };

    // New handler for "Use for Quotations" button
const handleUseForQuotations = (id, name) => {
  setSelectedSnapshotForQuote({ id, name });
  setOpenConfirmDialog(true);
};
const handleConfirmProceed = () => {
  // Logic to actually "proceed to quotations page"
  // In a real application, you'd likely use React Router's `useNavigate` here:
  // navigate(`/quotations?snapshotId=${selectedSnapshotForQuote.id}`);

  setSnackbarMessage(`Proceeding to quotations page using snapshot: ${selectedSnapshotForQuote.name} (ID: ${selectedSnapshotForQuote.id})`);
  setOpenSnackbar(true);
  setOpenConfirmDialog(false); // Close the dialog
};

const handleCloseConfirmDialog = () => {
  setOpenConfirmDialog(false);
  setSelectedSnapshotForQuote({ id: null, name: '' }); // Clear selected snapshot
};

const handleCloseSnackbar = (event, reason) => {
  if (reason === 'clickaway') {
    return;
  }
  setOpenSnackbar(false);
};

    // Comparison Logic
    const fetchAndProcessComparisonSnapshot = useCallback(async (snapshotId, setSnapshotData, setComparisonResults, dataIndex) => {
        if (!snapshotId) {
            setSnapshotData(null);
            setComparisonResults(null);
            return;
        }

        setComparisonLoading(true);
        setError('');
        try {
            const response = await axios.get(`${API_BASE_URL}/api/snapshots/${snapshotId}`);
            const fullSnapshotData = response.data.snapshot;
            const products = response.data.products.map(p => ({
                ...p,
                revenue_percentage: parseFloat(p.revenue_percentage) || 0,
                expected_units: parseFloat(p.expected_units) || 0,
                cost_per_unit: parseFloat(p.cost_per_unit) || 0,
                calculation_method: p.calculation_method || 'percentage', // Ensure calculation_method is present
            }));
            const expenses = (response.data.expenses || []).map(exp => ({
                ...exp,
                amount: parseFloat(exp.amount) || 0
            }));

            // Combine into a single object for calculation
            const combinedSnapshotData = {
                ...fullSnapshotData,
                total_cost: parseFloat(fullSnapshotData.total_cost) || 0,
                target_profit: parseFloat(fullSnapshotData.target_profit) || 0,
                target_margin: parseFloat(fullSnapshotData.target_margin) || 0,
                products,
                expenses
            };

            setSnapshotData(combinedSnapshotData);
            // This is where calculateSnapshotPrices is called with the loaded data
            setComparisonResults(calculateSnapshotPrices(combinedSnapshotData));
            setSuccessMessage(`Snapshot ${dataIndex} loaded for comparison: ${combinedSnapshotData.name}`);
        } catch (err) {
            console.error('Error fetching/processing snapshot for comparison:', err.response?.data?.message || err.message);
            setError(`Failed to load snapshot ${dataIndex} for comparison: ${err.response?.data?.message || err.message}`);
            setSnapshotData(null);
            setComparisonResults(null);
        } finally {
            setComparisonLoading(false);
        }
    }, [setError, setSuccessMessage]);

    useEffect(() => {
        fetchAndProcessComparisonSnapshot(selectedComparisonSnapshot1Id, setComparisonSnapshot1Data, setComparisonResults1, 1);
    }, [selectedComparisonSnapshot1Id, fetchAndProcessComparisonSnapshot]);

    useEffect(() => {
        fetchAndProcessComparisonSnapshot(selectedComparisonSnapshot2Id, setComparisonSnapshot2Data, setComparisonResults2, 2);
    }, [selectedComparisonSnapshot2Id, fetchAndProcessComparisonSnapshot]);

    const clearComparison = () => {
        setSelectedComparisonSnapshot1Id('');
        setSelectedComparisonSnapshot2Id('');
        setComparisonSnapshot1Data(null);
        setComparisonResults1(null);
        setComparisonResults2(null);
        setSuccessMessage('Comparison cleared.');
    };

    const renderComparisonColumn = (title, snapshot, results, id) => {
        if (!snapshot || !results) {
            return (
                <Grid item xs={12} sm={6}>
                    <Card elevation={2} sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                        <CardContent>
                            <Typography variant="h6" align="center" gutterBottom>{title}</Typography>
                            <Box display="flex" justifyContent="center" alignItems="center" height={150}>
                                <Typography color="text.secondary">No snapshot selected</Typography>
                            </Box>
                        </CardContent>
                    </Card>
                </Grid>
            );
        }

        return (
            <Grid item xs={12} sm={6}>
                <Card elevation={2} sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                    <CardContent sx={{ flexGrow: 1 }}>
                        <Typography variant="h6" align="center" gutterBottom>{snapshot.name}</Typography>
                        <Typography variant="caption" color="text.secondary" align="center" display="block" mb={1}>
                            {new Date(snapshot.created_at).toLocaleDateString()}
                        </Typography>
                        <Divider sx={{ my: 2 }} />

                        <Typography variant="subtitle1" fontWeight="bold" mt={2}>Overall Metrics:</Typography>
                        <Typography>Monthly Cost: R{results.actualCost.toFixed(2)}</Typography>
                        <Typography>Target {snapshot.use_margin ? `Margin: ${parseFloat(snapshot.target_margin) || 0}%` : `Profit: R${(parseFloat(snapshot.target_profit) || 0).toFixed(2)}`}</Typography>
                        <Typography>Calculated Profit: R{results.calculatedProfit.toFixed(2)}</Typography>
                        <Typography>Total Revenue: R{results.totalRevenue.toFixed(2)}</Typography>
                        <Typography>Cost Breakdown Used: {snapshot.use_breakdown ? 'Yes' : 'No'}</Typography>

                        {snapshot.use_breakdown && (
                            <Box mt={2}>
                                <Typography variant="subtitle2" fontWeight="bold">Individual Expenses:</Typography>
                                {snapshot.expenses.length > 0 ? (
                                    <List dense disablePadding>
                                        {snapshot.expenses.map((exp, idx) => (
                                            <ListItem key={idx} sx={{ py: 0.2 }}>
                                                <ListItemText primary={`${exp.label}: R${(parseFloat(exp.amount) || 0).toFixed(2)}`} />
                                            </ListItem>
                                        ))}
                                    </List>
                                ) : (
                                    <Typography variant="body2" color="text.secondary">No individual expenses recorded.</Typography>
                                )}
                            </Box>
                        )}

                        {Object.keys(snapshot.competitor_prices || {}).length > 0 && (
                            <Box mt={2}>
                                <Typography variant="subtitle2" fontWeight="bold">Competitor Prices:</Typography>
                                <List dense disablePadding>
                                    {Object.entries(snapshot.competitor_prices).map(([productName, price], idx) => (
                                        <ListItem key={idx} sx={{ py: 0.2 }}>
                                            <ListItemText primary={`${productName}: R${(parseFloat(price) || 0).toFixed(2)}`} />
                                        </ListItem>
                                    ))}
                                </List>
                            </Box>
                        )}

                        <Typography variant="subtitle1" fontWeight="bold" mt={3}>Product Details:</Typography>
                        {results.calculatedProducts.length > 0 ? (
                            results.calculatedProducts.map((product, index) => (
                                <Box key={index} sx={{ mb: 1.5, p: 1.5, border: '1px solid #eee', borderRadius: '8px', backgroundColor: '#f9f9f9' }}>
                                    <Typography variant="body1" fontWeight="bold">{product.name || `Product ${index + 1}`}</Typography>
                                    <Typography variant="body2">
                                        Calculation Method: {product.calculationMethod === 'percentage' ? 'Percentage Revenue' : 'Cost-Plus'}
                                    </Typography>
                                    {/* Display fields based on calculation method */}
                                    {product.calculationMethod === 'percentage' && (
                                        <>
                                            <Typography variant="body2">Revenue Share (Input): {product.percentage.toFixed(2)}%</Typography>
                                            <Typography variant="body2">Calculated Unit Price: R{product.suggestedPrice.toFixed(2)}</Typography>
                                            <Typography variant="body2">Units Needed to Sell: {product.unitsNeeded}</Typography>
                                            <Typography variant="body2">Actual Product Margin: {product.percentageRevenue.toFixed(2)}%</Typography>
                                        </>
                                    )}
                                    {product.calculationMethod === 'cost-plus' && (
                                        <>
                                            <Typography variant="body2">Expected Units: {product.expectedUnits}</Typography>
                                            <Typography variant="body2">Cost Per Unit: R{product.costPerUnit.toFixed(2)}</Typography>
                                            <Typography variant="body2">Calculated Profit Per Unit: R{product.suggestedProfit.toFixed(2)}</Typography>
                                            <Typography variant="body2">Calculated Unit Price: R{product.suggestedPrice.toFixed(2)}</Typography>
                                            <Typography variant="body2">Actual Product Margin: {product.percentageRevenue.toFixed(2)}%</Typography>
                                        </>
                                    )}
                                </Box>
                            ))
                        ) : (
                            <Typography color="text.secondary">No product data for this snapshot.</Typography>
                        )}
                    </CardContent>
                </Card>
            </Grid>
        );
    };

    const renderComparisonInsights = () => {
        if (!comparisonResults1 || !comparisonResults2 || !comparisonSnapshot1Data || !comparisonSnapshot2Data) {
            return null; // Don't render insights if not both snapshots are loaded
        }

        const s1 = comparisonResults1;
        const s2 = comparisonResults2;
        const s1Name = comparisonSnapshot1Data.name;
        const s2Name = comparisonSnapshot2Data.name;

        const insights = [];

        // 1. Profit Comparison
        if (s1.calculatedProfit > s2.calculatedProfit) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s1Name}</Typography> has a higher calculated profit of R{s1.calculatedProfit.toFixed(2)} compared to R{s2.calculatedProfit.toFixed(2)} from <Typography component="span" fontWeight="bold">{s2Name}</Typography>.
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** If maximizing overall profit is your primary goal, <Typography component="span" fontWeight="bold">{s1Name}</Typography> is the better choice.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        } else if (s2.calculatedProfit > s1.calculatedProfit) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s2Name}</Typography> has a higher calculated profit of R{s2.calculatedProfit.toFixed(2)} compared to R{s1.calculatedProfit.toFixed(2)} from <Typography component="span" fontWeight="bold">{s1Name}</Typography>.
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** For greater profitability, consider strategies aligned with <Typography component="span" fontWeight="bold">{s2Name}</Typography>.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        } else {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            Both snapshots yield a similar calculated profit of R{s1.calculatedProfit.toFixed(2)}.
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** If profit is equal, evaluate other factors like operational cost or unit prices.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        }

        // 2. Revenue Comparison
        if (s1.totalRevenue > s2.totalRevenue) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s1Name}</Typography> projects higher total revenue (R{s1.totalRevenue.toFixed(2)}) than <Typography component="span" fontWeight="bold">{s2Name}</Typography> (R{s2.totalRevenue.toFixed(2)}).
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** <Typography component="span" fontWeight="bold">{s1Name}</Typography> suggests a larger market reach or higher pricing strategy. This is ideal if revenue growth is a key objective, even if profit is similar.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        } else if (s2.totalRevenue > s1.totalRevenue) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s2Name}</Typography> projects higher total revenue (R{s2.totalRevenue.toFixed(2)}) than <Typography component="span" fontWeight="bold">{s1Name}</Typography> (R{s1.totalRevenue.toFixed(2)}).
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** If increasing top-line revenue is crucial, focus on the approach in <Typography component="span" fontWeight="bold">{s2Name}</Typography>.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        } else {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            Both snapshots project similar total revenue of R{s1.totalRevenue.toFixed(2)}.
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** With similar revenue, the decision might hinge on operational efficiency or ease of implementation.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        }

        // 3. Cost Comparison
        if (s1.actualCost < s2.actualCost) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s1Name}</Typography> involves a lower total monthly cost (R{s1.actualCost.toFixed(2)}) compared to <Typography component="span" fontWeight="bold">{s2Name}</Typography> (R{s2.actualCost.toFixed(2)}).
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** If cost efficiency is paramount, <Typography component="span" fontWeight="bold">{s1Name}</Typography> represents a more lean operation.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        } else if (s2.actualCost < s1.actualCost) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s2Name}</Typography> involves a lower total monthly cost (R{s2.actualCost.toFixed(2)}) compared to <Typography component="span" fontWeight="bold">{s1Name}</Typography> (R{s1.actualCost.toFixed(2)}).
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** To reduce fixed overheads, consider the approach in <Typography component="span" fontWeight="bold">{s2Name}</Typography>.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        } else {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            Both snapshots have similar total monthly costs of R{s1.actualCost.toFixed(2)}.
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** Costs are comparable; focus on revenue and profit generation.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        }

        // 4. Product-level insights (example: compare a specific product's price or margin)
        // This would require more complex matching of products by name/ID between snapshots.
        // For now, let's keep it high-level.

        return (
            <Grid item xs={12}>
                <Card elevation={2} sx={{ p: 3, mt: 3, backgroundColor: '#e8f5e9' }}>
                    <Typography variant="h5" gutterBottom>Comparison Insights</Typography>
                    <List dense>
                        {insights.length > 0 ? insights : (
                            <ListItem><ListItemText primary="No specific insights generated or values are too similar." /></ListItem>
                        )}
                    </List>
                </Card>
            </Grid>
        );
    };


    return (
        <Box sx={{ p: 3 }}>
            <Typography variant="h4" gutterBottom>Snapshot Manager</Typography>

            {loading && <CircularProgress sx={{ my: 2 }} />}
            {comparisonLoading && <CircularProgress size={24} sx={{ my: 2, ml: 2 }} />}
            {setError && <Alert severity="error" sx={{ my: 2 }}>{setError}</Alert>}
            {setSuccessMessage && <Alert severity="success" sx={{ my: 2 }}>{setSuccessMessage}</Alert>}

            {/* Save Snapshot Section */}
            <Paper elevation={3} sx={{ p: 3, mb: 3 }}>
                <Typography variant="h6" gutterBottom>Save Current Pricing Setup</Typography>
                <Box sx={{ display: 'flex', gap: 2, alignItems: 'center' }}>
                    <TextField
                        label="Snapshot Name"
                        variant="outlined"
                        value={snapshotName}
                        onChange={(e) => setSnapshotName(e.target.value)}
                        sx={{ flexGrow: 1 }}
                    />
                    <Button
                        variant="contained"
                        startIcon={<SaveIcon />}
                        onClick={handleSaveSnapshot}
                        disabled={loading || !snapshotName.trim()}
                    >
                        Save Snapshot
                    </Button>
                </Box>
            </Paper>

            {/* Load Snapshots Section */}
            <Paper elevation={3} sx={{ p: 3, mb: 3 }}>
                <Typography variant="h6" gutterBottom>Load Existing Snapshot</Typography>
                <Button
                    variant="outlined"
                    startIcon={<FolderOpenIcon />}
                    onClick={() => {
                        fetchSnapshots(); // Refresh list just before opening
                        setOpenLoadDialog(true);
                    }}
                    disabled={loading}
                >
                    Load Snapshot
                </Button>

                <Dialog open={openLoadDialog} onClose={() => setOpenLoadDialog(false)} fullWidth maxWidth="md">
                    <DialogTitle>Load Snapshot</DialogTitle>
                    <DialogContent>
                        {loading ? (
                            <Box display="flex" justifyContent="center" alignItems="center" height={100}>
                                <CircularProgress />
                            </Box>
                        ) : savedSnapshots.length === 0 ? (
                            <Typography>No snapshots saved yet.</Typography>
                        ) : (
                            <List>
                                {savedSnapshots.map((snapshot) => (
                                    <ListItem key={snapshot.id} divider>
                                        <ListItemText
                                            primary={snapshot.name}
                                            secondary={`Saved on: ${new Date(snapshot.created_at).toLocaleDateString()} at ${new Date(snapshot.created_at).toLocaleTimeString()}`}
                                        />
                                        <ListItemSecondaryAction>
                                            <Button
                                                variant="outlined"
                                                size="small"
                                                onClick={() => handleLoadSnapshot(snapshot.id)}
                                                sx={{ mr: 1 }}
                                            >
                                                Load
                                            </Button>
                                               <Button
      variant="contained"
      color="primary"
      size="small"
      startIcon={<CheckCircleIcon />}
      onClick={() => handleUseForQuotations(snapshot.id, snapshot.name)}
      sx={{ mr: 1 }}
    >
      Use for Quotations
    </Button>
    <Dialog
      open={openConfirmDialog}
      onClose={handleCloseConfirmDialog}
      aria-labelledby="confirm-dialog-title"
      aria-describedby="confirm-dialog-description"
    >
      <DialogTitle id="confirm-dialog-title">Confirm Action</DialogTitle>
      <DialogContent>
        <DialogContentText id="confirm-dialog-description">
          Are you sure you want to proceed to the quotations page using snapshot:
          <br />
          <strong>{selectedSnapshotForQuote.name}</strong> (ID: {selectedSnapshotForQuote.id})?
        </DialogContentText>
      </DialogContent>
      <DialogActions>
        <Button onClick={handleCloseConfirmDialog} color="primary">
          Cancel
        </Button>
        <Button onClick={handleConfirmProceed} color="primary" autoFocus>
          Proceed
        </Button>
      </DialogActions>
    </Dialog>
    {/* Snackbar for confirmation message */}
    <Snackbar
      open={openSnackbar}
      autoHideDuration={6000} // How long the snackbar stays open
      onClose={handleCloseSnackbar}
      anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }} // Position of the snackbar
    >
      <Alert onClose={handleCloseSnackbar} severity="success" sx={{ width: '100%' }}>
        {snackbarMessage}
      </Alert>
    </Snackbar>
    
                                            <IconButton
                                                edge="end"
                                                aria-label="delete"
                                                onClick={() => {
                                                    setSnapshotToDelete(snapshot);
                                                    setOpenDeleteDialog(true);
                                                }}
                                            >
                                                <DeleteIcon color="error" />
                                            </IconButton>
                                        </ListItemSecondaryAction>
                                    </ListItem>
                                ))}
                            </List>
                        )}
                    </DialogContent>
                    <DialogActions>
                        <Button onClick={() => setOpenLoadDialog(false)}>Close</Button>
                    </DialogActions>
                </Dialog>
            </Paper>

            {/* Delete Confirmation Dialog */}
            <Dialog open={openDeleteDialog} onClose={() => setOpenDeleteDialog(false)}>
                <DialogTitle>Confirm Delete</DialogTitle>
                <DialogContent>
                    <Typography>Are you sure you want to delete snapshot "<strong>{snapshotToDelete?.name}</strong>"? This action cannot be undone.</Typography>
                </DialogContent>
                <DialogActions>
                    <Button onClick={() => setOpenDeleteDialog(false)} color="primary">Cancel</Button>
                    <Button onClick={handleDeleteSnapshot} color="error" variant="contained">Delete</Button>
                </DialogActions>
            </Dialog>

            {/* Comparison Section (as it was before) */}
            <Paper elevation={3} sx={{ p: 3, mb: 3 }}>
                <Typography variant="h6" gutterBottom>Compare Snapshots</Typography>
                <Grid container spacing={2} alignItems="center" mb={2}>
                    <Grid item xs={12} sm={5}>
                        <TextField
                            select
                            label="Snapshot 1"
                            fullWidth
                            value={selectedComparisonSnapshot1Id}
                            onChange={(e) => setSelectedComparisonSnapshot1Id(e.target.value)}
                            disabled={comparisonLoading}
                            size="small"
                        >
                            <MenuItem value="">
                                <em>None</em>
                            </MenuItem>
                            {savedSnapshots.map((snapshot) => (
                                <MenuItem key={snapshot.id} value={snapshot.id}>
                                    {snapshot.name}
                                </MenuItem>
                            ))}
                        </TextField>
                    </Grid>
                    <Grid item xs={12} sm={5}>
                        <TextField
                            select
                            label="Snapshot 2"
                            fullWidth
                            value={selectedComparisonSnapshot2Id}
                            onChange={(e) => setSelectedComparisonSnapshot2Id(e.target.value)}
                            disabled={comparisonLoading}
                            size="small"
                        >
                            <MenuItem value="">
                                <em>None</em>
                            </MenuItem>
                            {savedSnapshots.map((snapshot) => (
                                <MenuItem key={snapshot.id} value={snapshot.id}>
                                    {snapshot.name}
                                </MenuItem>
                            ))}
                        </TextField>
                    </Grid>
                    <Grid item xs={12} sm={2}>
                        <Button
                            variant="outlined"
                            onClick={clearComparison}
                            startIcon={<ClearIcon />}
                            disabled={comparisonLoading || (!selectedComparisonSnapshot1Id && !selectedComparisonSnapshot2Id)}
                            fullWidth
                        >
                            Clear
                        </Button>
                    </Grid>
                </Grid>

                {(comparisonLoading && (selectedComparisonSnapshot1Id || selectedComparisonSnapshot2Id)) && (
                    <Box display="flex" justifyContent="center" alignItems="center" my={2}>
                        <CircularProgress />
                        <Typography ml={2}>Loading comparison data...</Typography>
                    </Box>
                )}

                <Grid container spacing={3}>
                    {renderComparisonColumn("Snapshot 1", comparisonSnapshot1Data, comparisonResults1, selectedComparisonSnapshot1Id)}
                    {renderComparisonColumn("Snapshot 2", comparisonSnapshot2Data, comparisonResults2, selectedComparisonSnapshot2Id)}
                    {renderComparisonInsights()}
                </Grid>
            </Paper>
        </Box>
    );
};

export default SnapshotManager;
