import React, { useState, useEffect, useCallback } from 'react';
import {
    Box, Button, TextField, Typography, List, ListItem, ListItemText,
    ListItemSecondaryAction, IconButton, Dialog, DialogTitle, DialogContent,
    DialogActions, CircularProgress, Alert, Grid, Card, CardContent, Divider
} from '@mui/material';
import SaveIcon from '@mui/icons-material/Save';
import FolderOpenIcon from '@mui/icons-material/FolderOpen';
import DeleteIcon from '@mui/icons-material/Delete';
import ClearIcon from '@mui/icons-material/Clear';
import axios from 'axios';

const API_BASE_URL = 'https://priceaibback.onrender.com:5000'; // Ensure this matches your backend URL

// Helper function to calculate derived pricing metrics from raw snapshot data
// IMPORTANT: This function is primarily for DISPLAYING comparison data within SnapshotManager.
// The primary calculation logic for the main app should remain in PricingPage.jsx's calculatePrices.
const calculateSnapshotPrices = (snapshotData) => {
    const { total_cost, use_margin, target_profit, target_margin, use_breakdown, products, expenses } = snapshotData;

    // Ensure total_cost is a number
    const safeTotalCost = parseFloat(total_cost) || 0;

    const actualCost = use_breakdown
        ? expenses.reduce((sum, c) => sum + (parseFloat(c.amount) || 0), 0)
        : safeTotalCost;

    const totalVariableCosts = products.reduce((sum, product) => {
        return sum + (parseFloat(product.cost_per_unit) * parseFloat(product.expected_units));
    }, 0);

    const overallTotalCostForRevenueCalculation = actualCost + totalVariableCosts;

    let totalRevenueValue = 0;
    let calculatedProfit = 0;

    if (use_margin) {
        const safeTargetMargin = parseFloat(target_margin) || 0;
        if (safeTargetMargin >= 100) {
            totalRevenueValue = 0;
            calculatedProfit = 0;
        } else {
            totalRevenueValue = overallTotalCostForRevenueCalculation / (1 - safeTargetMargin / 100);
            calculatedProfit = totalRevenueValue - overallTotalCostForRevenueCalculation;
        }
    } else {
        const safeTargetProfit = parseFloat(target_profit) || 0;
        calculatedProfit = safeTargetProfit;
        totalRevenueValue = overallTotalCostForRevenueCalculation + safeTargetProfit;
    }

    // --- Start of Cost-Plus / Percentage specific calculation for comparison display ---
    const percentageBasedProducts = products.filter(p => p.calculation_method === 'percentage');
    const costPlusBasedProducts = products.filter(p => p.calculation_method === 'cost-plus');

    // Calculate fixed cost allocated to percentage-based products based on their % revenue share
    // This part assumes that the percentage values stored in snapshots are already 0-1 (as saved)
    const fixedCostAllocatedToPercentageProducts = percentageBasedProducts.reduce((sum, p) => {
        // Need to know what total revenue percentage these products make up to allocate fixed cost
        // If snapshot data only has individual product revenue_percentage, we assume those are already
        // ratios relative to total revenue.
        const productExpectedRevenue = (parseFloat(p.revenue_percentage) || 0) * totalRevenueValue;
        return sum + ((productExpectedRevenue / totalRevenueValue) * actualCost); // Ratio of their expected revenue to total revenue, applied to total fixed cost
    }, 0);


    // Remaining fixed costs to be covered by cost-plus products
    const fixedCostAllocatedToCostPlusProducts = actualCost - fixedCostAllocatedToPercentageProducts;

    // Calculate the profit generated by percentage-based products (based on their revenue share of overall target profit)
    const profitFromPercentageProducts = percentageBasedProducts.reduce((sum, p) => {
        const productExpectedRevenue = (parseFloat(p.revenue_percentage) || 0) * totalRevenueValue;
        const productVariableCost = (parseFloat(p.cost_per_unit) || 0) * (parseFloat(p.expected_units) || 0);
        const productAllocatedFixedCost = ((productExpectedRevenue / totalRevenueValue) * actualCost); // Re-use the fixed cost allocation logic
        return sum + (productExpectedRevenue - productVariableCost - productAllocatedFixedCost);
    }, 0);

    // The remaining profit that MUST be covered by cost-plus products to hit the overall target profit
    const profitNeededFromCostPlusProducts = calculatedProfit - profitFromPercentageProducts;

    // Total expected units from ALL cost-plus products
    const totalExpectedUnitsCostPlus = costPlusBasedProducts.reduce((sum, p) => sum + (parseFloat(p.expected_units) || 0), 0);


    const calculatedProducts = products.map((product) => {
        const safeExpectedUnits = parseFloat(product.expected_units) > 0 ? parseFloat(product.expected_units) : 1;
        const safeCostPerUnit = parseFloat(product.cost_per_unit) || 0;
        const calculationMethod = product.calculation_method || 'percentage'; // Default to percentage if not present

        let suggestedPrice = 0;
        let percentageRevenue = 0; // This will be the actual revenue percentage for the product
        let suggestedProfitPerUnit = 0;

        if (calculationMethod === 'percentage') {
            const safeRevenuePercentage = parseFloat(product.revenue_percentage) || 0; // Already 0-1 from saved data
            const revenueShare = safeRevenuePercentage * totalRevenueValue;
            suggestedPrice = safeExpectedUnits > 0 ? (revenueShare / safeExpectedUnits) : 0;
            suggestedPrice = Math.round(suggestedPrice * 100) / 100;

            const productRevenue = suggestedPrice * safeExpectedUnits;
            const productVariableCost = safeCostPerUnit * safeExpectedUnits;
            const productAllocatedFixedCost = (productRevenue / totalRevenueValue) * actualCost; // Fixed cost allocated based on its calculated revenue share
            const productProfit = productRevenue - productVariableCost - productAllocatedFixedCost;
            percentageRevenue = productRevenue > 0 ? (productProfit / productRevenue) * 100 : 0; // Actual profit margin for this product
            suggestedProfitPerUnit = safeExpectedUnits > 0 ? productProfit / safeExpectedUnits : 0;

        } else { // 'cost-plus' method
            let profitContributionPerUnit = 0;
            let fixedCostContributionPerUnit = 0;

            if (totalExpectedUnitsCostPlus > 0) {
                profitContributionPerUnit = profitNeededFromCostPlusProducts / totalExpectedUnitsCostPlus;
                fixedCostContributionPerUnit = fixedCostAllocatedToCostPlusProducts / totalExpectedUnitsCostPlus;
            } else if (costPlusBasedProducts.length === 1 && safeExpectedUnits > 0) {
                 // Special case: if only one cost-plus product, it covers all remaining fixed and profit
                 profitContributionPerUnit = profitNeededFromCostPlusProducts; // This should be total profit needed from this product
                 fixedCostContributionPerUnit = fixedCostAllocatedToCostPlusProducts; // Total fixed cost needed from this product
                 profitContributionPerUnit = profitContributionPerUnit / safeExpectedUnits; // per unit
                 fixedCostContributionPerUnit = fixedCostContributionPerUnit / safeExpectedUnits; // per unit
            }

            suggestedProfitPerUnit = profitContributionPerUnit + fixedCostContributionPerUnit;
            suggestedPrice = safeCostPerUnit + suggestedProfitPerUnit;
            suggestedPrice = Math.round(suggestedPrice * 100) / 100;

            const productRevenue = suggestedPrice * safeExpectedUnits;
            const productTotalCost = (safeCostPerUnit * safeExpectedUnits) + (fixedCostContributionPerUnit * safeExpectedUnits);
            percentageRevenue = productRevenue > 0 ? ((productRevenue - productTotalCost) / productRevenue) * 100 : 0;
        }

        return {
            name: product.name,
            // For display, 'percentage' is only relevant for percentage-based products
            percentage: calculationMethod === 'percentage' ? (parseFloat(product.revenue_percentage) || 0) * 100 : 0,
            expectedUnits: parseFloat(product.expected_units) || 0,
            costPerUnit: safeCostPerUnit,
            suggestedPrice: suggestedPrice,
            // unitsNeeded is primarily for percentage method; for cost-plus, it's generally expectedUnits
            unitsNeeded: calculationMethod === 'percentage' ? (suggestedPrice > 0 ? Math.ceil((parseFloat(product.revenue_percentage) || 0) * totalRevenueValue / suggestedPrice) : 0) : product.expected_units,
            percentageRevenue: percentageRevenue, // This is the actual calculated profit margin percentage for the product
            calculationMethod: calculationMethod,
            suggestedProfit: suggestedProfitPerUnit, // The per-unit profit, crucial for cost-plus products
        };
    });

    return {
        actualCost: parseFloat(actualCost) || 0,
        totalRevenue: parseFloat(totalRevenueValue) || 0,
        calculatedProfit: parseFloat(calculatedProfit) || 0,
        calculatedProducts,
        inputs: snapshotData // Keep original inputs for display
    };
};


const SnapshotManager = ({
    loading,
    setLoading,
    setError,
    setSuccessMessage,
    currentPricingState,
    onSnapshotLoaded,
    onCalculatePrices, // Added to trigger recalculation in parent after loading
    setActiveTab // To switch tabs after loading
}) => {
    const [snapshotName, setSnapshotName] = useState('');
    const [savedSnapshots, setSavedSnapshots] = useState([]);
    const [openLoadDialog, setOpenLoadDialog] = useState(false);
    const [openDeleteDialog, setOpenDeleteDialog] = useState(false);
    const [snapshotToDelete, setSnapshotToDelete] = useState(null);

    // New state for comparison feature
    const [selectedComparisonSnapshot1Id, setSelectedComparisonSnapshot1Id] = useState('');
    const [selectedComparisonSnapshot2Id, setSelectedComparisonSnapshot2Id] = useState('');
    const [comparisonSnapshot1Data, setComparisonSnapshot1Data] = useState(null);
    const [comparisonResults1, setComparisonResults1] = useState(null);
    const [comparisonSnapshot2Data, setComparisonSnapshot2Data] = useState(null);
    const [comparisonResults2, setComparisonResults2] = useState(null);
    const [comparisonLoading, setComparisonLoading] = useState(false);


    const fetchSnapshots = useCallback(async () => {
        setLoading(true);
        setError('');
        try {
            const response = await axios.get(`${API_BASE_URL}/api/snapshots`);
            setSavedSnapshots(response.data);
        } catch (err) {
            console.error('Error fetching snapshots:', err.response?.data?.message || err.message);
            setError(`Failed to fetch snapshots: ${err.response?.data?.message || err.message}`);
        } finally {
            setLoading(false);
        }
    }, [setLoading, setError]);

    useEffect(() => {
        fetchSnapshots();
    }, [fetchSnapshots]);


    const handleSaveSnapshot = async () => {
        if (!snapshotName.trim()) {
            setError('Please enter a name for the snapshot.');
            return;
        }
        setLoading(true);
        setError('');
        setSuccessMessage('');

        const snapshotData = {
            name: snapshotName,
            total_cost: parseFloat(currentPricingState.totalCost) || 0,
            use_margin: currentPricingState.useMargin,
            target_profit: parseFloat(currentPricingState.targetProfit) || 0,
            target_margin: parseFloat(currentPricingState.targetMargin) || 0,
            use_breakdown: currentPricingState.useBreakdown,
            competitor_prices: currentPricingState.competitorPrices || {},
            products: currentPricingState.products.map(p => ({
                name: p.name,
                // Save based on calculationMethod:
                // For 'percentage', save revenue_percentage (0-1)
                // For 'cost-plus', this field is not directly used for input, so save 0.
                revenue_percentage: p.calculationMethod === 'percentage' ? (parseFloat(p.percentage) / 100) || 0 : 0,
                expected_units: parseFloat(p.expectedUnits) || 0,
                cost_per_unit: parseFloat(p.costPerUnit) || 0,
                calculation_method: p.calculationMethod, // Save the calculation method
            })),
            expenses: currentPricingState.useBreakdown ? currentPricingState.individualCosts.map(exp => ({
                ...exp,
                amount: parseFloat(exp.amount) || 0
            })) : [],
        };

        try {
            await axios.post(`${API_BASE_URL}/api/snapshots`, snapshotData);
            setSuccessMessage(`Snapshot "${snapshotName}" saved successfully!`);
            setSnapshotName('');
            fetchSnapshots(); // Refresh the list of saved snapshots
        } catch (err) {
            console.error('Error saving snapshot:', err.response?.data?.message || err.message);
            setError(`Failed to save snapshot: ${err.response?.data?.message || err.message}`);
        } finally {
            setLoading(false);
        }
    };

    const handleLoadSnapshot = async (id) => {
        setLoading(true);
        setError('');
        setSuccessMessage('');
        try {
            const response = await axios.get(`${API_BASE_URL}/api/snapshots/${id}`);
            const snapshot = response.data.snapshot;
            const products = response.data.products.map(p => {
                const loadedPercentage = (parseFloat(p.revenue_percentage) || 0) * 100; // Convert to 0-100 for frontend

                return {
                    name: p.name,
                    percentage: loadedPercentage, // This is for percentage-based input
                    expectedUnits: parseFloat(p.expected_units) || 0,
                    costPerUnit: parseFloat(p.cost_per_unit) || 0,
                    calculationMethod: p.calculation_method || 'percentage', // Crucial: load the method
                    // These fields will be recalculated by PricingPage after load
                    suggestedProfit: 0,
                    price: 0,
                    unitsNeeded: 0,
                    percentageRevenue: 0,
                };
            });
            const expenses = (response.data.expenses || []).map(exp => ({
                ...exp,
                amount: parseFloat(exp.amount) || 0
            }));

            onSnapshotLoaded({
                name: snapshot.name,
                totalCost: parseFloat(snapshot.total_cost) || 0,
                useMargin: snapshot.use_margin,
                targetProfit: parseFloat(snapshot.target_profit) || 0,
                targetMargin: parseFloat(snapshot.target_margin) || 0,
                useBreakdown: snapshot.use_breakdown,
                individualCosts: expenses,
                products: products,
                competitorPrices: snapshot.competitor_prices || {},
            });
            setSuccessMessage(`Snapshot "${snapshot.name}" loaded successfully!`);
            setOpenLoadDialog(false);
            if (onCalculatePrices) {
                onCalculatePrices(); // Trigger price recalculation in parent's PricingPage
            }
            if (setActiveTab) {
                setActiveTab(0); // Switch to Setup tab after loading a snapshot
            }
        } catch (err) {
            console.error('Error loading snapshot:', err.response?.data?.message || err.message);
            setError(`Failed to load snapshot: ${err.response?.data?.message || err.message}`);
        } finally {
            setLoading(false);
        }
    };

    const handleDeleteSnapshot = async () => {
        if (!snapshotToDelete) return;

        setLoading(true);
        setError('');
        setSuccessMessage('');
        try {
            await axios.delete(`${API_BASE_URL}/api/snapshots/${snapshotToDelete.id}`);
            setSuccessMessage(`Snapshot "${snapshotToDelete.name}" deleted successfully!`);
            fetchSnapshots(); // Refresh list
            // If deleted snapshot was part of comparison, clear it
            if (selectedComparisonSnapshot1Id === snapshotToDelete.id) {
                setSelectedComparisonSnapshot1Id('');
                setComparisonSnapshot1Data(null);
                setComparisonResults1(null);
            }
            if (selectedComparisonSnapshot2Id === snapshotToDelete.id) {
                setSelectedComparisonSnapshot2Id('');
                setComparisonSnapshot2Data(null);
                setComparisonResults2(null);
            }
        } catch (err) {
            console.error('Error deleting snapshot:', err.response?.data?.message || err.message);
            setError(`Failed to delete snapshot: ${err.response?.data?.message || err.message}`);
        } finally {
            setLoading(false);
            setOpenDeleteDialog(false);
            setSnapshotToDelete(null);
        }
    };

    // Comparison Logic
    const fetchAndProcessComparisonSnapshot = useCallback(async (snapshotId, setSnapshotData, setComparisonResults, dataIndex) => {
        if (!snapshotId) {
            setSnapshotData(null);
            setComparisonResults(null);
            return;
        }

        setComparisonLoading(true);
        setError('');
        try {
            const response = await axios.get(`${API_BASE_URL}/api/snapshots/${snapshotId}`);
            const fullSnapshotData = response.data.snapshot;
            const products = response.data.products.map(p => ({
                ...p,
                revenue_percentage: parseFloat(p.revenue_percentage) || 0,
                expected_units: parseFloat(p.expected_units) || 0,
                cost_per_unit: parseFloat(p.cost_per_unit) || 0,
                calculation_method: p.calculation_method || 'percentage', // Ensure calculation_method is present
            }));
            const expenses = (response.data.expenses || []).map(exp => ({
                ...exp,
                amount: parseFloat(exp.amount) || 0
            }));

            // Combine into a single object for calculation
            const combinedSnapshotData = {
                ...fullSnapshotData,
                total_cost: parseFloat(fullSnapshotData.total_cost) || 0,
                target_profit: parseFloat(fullSnapshotData.target_profit) || 0,
                target_margin: parseFloat(fullSnapshotData.target_margin) || 0,
                products,
                expenses
            };

            setSnapshotData(combinedSnapshotData);
            // This is where calculateSnapshotPrices is called with the loaded data
            setComparisonResults(calculateSnapshotPrices(combinedSnapshotData));
            setSuccessMessage(`Snapshot ${dataIndex} loaded for comparison: ${combinedSnapshotData.name}`);
        } catch (err) {
            console.error('Error fetching/processing snapshot for comparison:', err.response?.data?.message || err.message);
            setError(`Failed to load snapshot ${dataIndex} for comparison: ${err.response?.data?.message || err.message}`);
            setSnapshotData(null);
            setComparisonResults(null);
        } finally {
            setComparisonLoading(false);
        }
    }, [setError, setSuccessMessage]);

    useEffect(() => {
        fetchAndProcessComparisonSnapshot(selectedComparisonSnapshot1Id, setComparisonSnapshot1Data, setComparisonResults1, 1);
    }, [selectedComparisonSnapshot1Id, fetchAndProcessComparisonSnapshot]);

    useEffect(() => {
        fetchAndProcessComparisonSnapshot(selectedComparisonSnapshot2Id, setComparisonSnapshot2Data, setComparisonResults2, 2);
    }, [selectedComparisonSnapshot2Id, fetchAndProcessComparisonSnapshot]);

    const clearComparison = () => {
        setSelectedComparisonSnapshot1Id('');
        setSelectedComparisonSnapshot2Id('');
        setComparisonSnapshot1Data(null);
        setComparisonSnapshot2Data(null);
        setComparisonResults1(null);
        setComparisonResults2(null);
        setSuccessMessage('Comparison cleared.');
    };

    const renderComparisonColumn = (title, snapshot, results, id) => {
        if (!snapshot || !results) {
            return (
                <Grid item xs={12} sm={6}>
                    <Card elevation={2} sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                        <CardContent>
                            <Typography variant="h6" align="center" gutterBottom>{title}</Typography>
                            <Box display="flex" justifyContent="center" alignItems="center" height={150}>
                                <Typography color="text.secondary">No snapshot selected</Typography>
                            </Box>
                        </CardContent>
                    </Card>
                </Grid>
            );
        }

        return (
            <Grid item xs={12} sm={6}>
                <Card elevation={2} sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
                    <CardContent sx={{ flexGrow: 1 }}>
                        <Typography variant="h6" align="center" gutterBottom>{snapshot.name}</Typography>
                        <Typography variant="caption" color="text.secondary" align="center" display="block" mb={1}>
                            {new Date(snapshot.created_at).toLocaleDateString()}
                        </Typography>
                        <Divider sx={{ my: 2 }} />

                        <Typography variant="subtitle1" fontWeight="bold" mt={2}>Overall Metrics:</Typography>
                        <Typography>Monthly Cost: R{results.actualCost.toFixed(2)}</Typography>
                        <Typography>Target {snapshot.use_margin ? `Margin: ${parseFloat(snapshot.target_margin) || 0}%` : `Profit: R${(parseFloat(snapshot.target_profit) || 0).toFixed(2)}`}</Typography>
                        <Typography>Calculated Profit: R{results.calculatedProfit.toFixed(2)}</Typography>
                        <Typography>Total Revenue: R{results.totalRevenue.toFixed(2)}</Typography>
                        <Typography>Cost Breakdown Used: {snapshot.use_breakdown ? 'Yes' : 'No'}</Typography>

                        {snapshot.use_breakdown && (
                            <Box mt={2}>
                                <Typography variant="subtitle2" fontWeight="bold">Individual Expenses:</Typography>
                                {snapshot.expenses.length > 0 ? (
                                    <List dense disablePadding>
                                        {snapshot.expenses.map((exp, idx) => (
                                            <ListItem key={idx} sx={{ py: 0.2 }}>
                                                <ListItemText primary={`${exp.label}: R${(parseFloat(exp.amount) || 0).toFixed(2)}`} />
                                            </ListItem>
                                        ))}
                                    </List>
                                ) : (
                                    <Typography variant="body2" color="text.secondary">No individual expenses recorded.</Typography>
                                )}
                            </Box>
                        )}

                        {Object.keys(snapshot.competitor_prices || {}).length > 0 && (
                            <Box mt={2}>
                                <Typography variant="subtitle2" fontWeight="bold">Competitor Prices:</Typography>
                                <List dense disablePadding>
                                    {Object.entries(snapshot.competitor_prices).map(([productName, price], idx) => (
                                        <ListItem key={idx} sx={{ py: 0.2 }}>
                                            <ListItemText primary={`${productName}: R${(parseFloat(price) || 0).toFixed(2)}`} />
                                        </ListItem>
                                    ))}
                                </List>
                            </Box>
                        )}

                        <Typography variant="subtitle1" fontWeight="bold" mt={3}>Product Details:</Typography>
                        {results.calculatedProducts.length > 0 ? (
                            results.calculatedProducts.map((product, index) => (
                                <Box key={index} sx={{ mb: 1.5, p: 1.5, border: '1px solid #eee', borderRadius: '8px', backgroundColor: '#f9f9f9' }}>
                                    <Typography variant="body1" fontWeight="bold">{product.name || `Product ${index + 1}`}</Typography>
                                    <Typography variant="body2">
                                        Calculation Method: {product.calculationMethod === 'percentage' ? 'Percentage Revenue' : 'Cost-Plus'}
                                    </Typography>
                                    {/* Display fields based on calculation method */}
                                    {product.calculationMethod === 'percentage' && (
                                        <>
                                            <Typography variant="body2">Revenue Share (Input): {product.percentage.toFixed(2)}%</Typography>
                                            <Typography variant="body2">Calculated Unit Price: R{product.suggestedPrice.toFixed(2)}</Typography>
                                            <Typography variant="body2">Units Needed to Sell: {product.unitsNeeded}</Typography>
                                            <Typography variant="body2">Actual Product Margin: {product.percentageRevenue.toFixed(2)}%</Typography>
                                        </>
                                    )}
                                    {product.calculationMethod === 'cost-plus' && (
                                        <>
                                            <Typography variant="body2">Expected Units: {product.expectedUnits}</Typography>
                                            <Typography variant="body2">Cost Per Unit: R{product.costPerUnit.toFixed(2)}</Typography>
                                            <Typography variant="body2">Calculated Profit Per Unit: R{product.suggestedProfit.toFixed(2)}</Typography>
                                            <Typography variant="body2">Calculated Unit Price: R{product.suggestedPrice.toFixed(2)}</Typography>
                                            <Typography variant="body2">Actual Product Margin: {product.percentageRevenue.toFixed(2)}%</Typography>
                                        </>
                                    )}
                                </Box>
                            ))
                        ) : (
                            <Typography color="text.secondary">No product data for this snapshot.</Typography>
                        )}
                    </CardContent>
                </Card>
            </Grid>
        );
    };

    const renderComparisonInsights = () => {
        if (!comparisonResults1 || !comparisonResults2 || !comparisonSnapshot1Data || !comparisonSnapshot2Data) {
            return null; // Don't render insights if not both snapshots are loaded
        }

        const s1 = comparisonResults1;
        const s2 = comparisonResults2;
        const s1Name = comparisonSnapshot1Data.name;
        const s2Name = comparisonSnapshot2Data.name;

        const insights = [];

        // 1. Profit Comparison
        if (s1.calculatedProfit > s2.calculatedProfit) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s1Name}</Typography> has a higher calculated profit of R{s1.calculatedProfit.toFixed(2)} compared to R{s2.calculatedProfit.toFixed(2)} from <Typography component="span" fontWeight="bold">{s2Name}</Typography>.
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** If maximizing overall profit is your primary goal, <Typography component="span" fontWeight="bold">{s1Name}</Typography> is the better choice.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        } else if (s2.calculatedProfit > s1.calculatedProfit) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s2Name}</Typography> has a higher calculated profit of R{s2.calculatedProfit.toFixed(2)} compared to R{s1.calculatedProfit.toFixed(2)} from <Typography component="span" fontWeight="bold">{s1Name}</Typography>.
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** For greater profitability, consider strategies aligned with <Typography component="span" fontWeight="bold">{s2Name}</Typography>.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        } else {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            Both snapshots yield a similar calculated profit of R{s1.calculatedProfit.toFixed(2)}.
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** If profit is equal, evaluate other factors like operational cost or unit prices.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        }

        // 2. Revenue Comparison
        if (s1.totalRevenue > s2.totalRevenue) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s1Name}</Typography> projects higher total revenue (R{s1.totalRevenue.toFixed(2)}) than <Typography component="span" fontWeight="bold">{s2Name}</Typography> (R{s2.totalRevenue.toFixed(2)}).
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** <Typography component="span" fontWeight="bold">{s1Name}</Typography> suggests a larger market reach or higher pricing strategy. This is ideal if revenue growth is a key objective, even if profit is similar.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        } else if (s2.totalRevenue > s1.totalRevenue) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s2Name}</Typography> projects higher total revenue (R{s2.totalRevenue.toFixed(2)}) than <Typography component="span" fontWeight="bold">{s1Name}</Typography> (R{s1.totalRevenue.toFixed(2)}).
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** If increasing top-line revenue is crucial, focus on the approach in <Typography component="span" fontWeight="bold">{s2Name}</Typography>.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        }

        // 3. Cost Comparison
        if (s1.actualCost < s2.actualCost) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s1Name}</Typography> has a lower monthly operational cost (R{s1.actualCost.toFixed(2)}) compared to <Typography component="span" fontWeight="bold">{s2Name}</Typography> (R{s2.actualCost.toFixed(2)}).
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** <Typography component="span" fontWeight="bold">{s1Name}</Typography> indicates better cost efficiency. This is beneficial if cost reduction is a priority.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        } else if (s2.actualCost < s1.actualCost) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s2Name}</Typography> has a lower monthly operational cost (R{s2.actualCost.toFixed(2)}) compared to <Typography component="span" fontWeight="bold">{s1Name}</Typography> (R{s1.actualCost.toFixed(2)}).
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** <Typography component="span" fontWeight="bold">{s2Name}</Typography> is more cost-effective.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        }

        // 4. Margin vs. Profit Goal
        if (comparisonSnapshot1Data.use_margin !== comparisonSnapshot2Data.use_margin) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s1Name}</Typography> uses a {comparisonSnapshot1Data.use_margin ? `Target Margin of ${parseFloat(comparisonSnapshot1Data.target_margin).toFixed(2)}%` : `Target Profit of R${(parseFloat(comparisonSnapshot1Data.target_profit) || 0).toFixed(2)}`}, while <Typography component="span" fontWeight="bold">{s2Name}</Typography> uses a {comparisonSnapshot2Data.use_margin ? `Target Margin of ${parseFloat(comparisonSnapshot2Data.target_margin).toFixed(2)}%` : `Target Profit of R${(parseFloat(comparisonSnapshot2Data.target_profit) || 0).toFixed(2)}`}.
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** This highlights different strategic focuses. Target Margin (e.g., in {comparisonSnapshot1Data.use_margin ? s1Name : s2Name}) prioritizes a consistent profit percentage per revenue, good for scalable businesses. Target Profit (e.g., in {comparisonSnapshot1Data.use_margin ? s2Name : s1Name}) aims for a fixed monetary gain, useful for specific project goals.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        } else if (comparisonSnapshot1Data.use_margin) { // Both use margin
            const s1Margin = parseFloat(comparisonSnapshot1Data.target_margin) || 0;
            const s2Margin = parseFloat(comparisonSnapshot2Data.target_margin) || 0;
            if (s1Margin > s2Margin) {
                insights.push(
                    <ListItem>
                        <ListItemText primary={
                            <Typography>
                                <Typography component="span" fontWeight="bold">{s1Name}</Typography> aims for a higher target margin ({s1Margin.toFixed(2)}%) than <Typography component="span" fontWeight="bold">{s2Name}</Typography> ({s2Margin.toFixed(2)}%).
                                <br />
                                <Typography variant="body2" color="text.secondary">
                                    **Insight:** If maintaining a healthy profit margin is key, <Typography component="span" fontWeight="bold">{s1Name}</Typography> is more aggressive on margin percentage.
                                </Typography>
                            </Typography>
                        } />
                    </ListItem>
                );
            } else if (s2Margin > s1Margin) {
                insights.push(
                    <ListItem>
                        <ListItemText primary={
                            <Typography>
                                <Typography component="span" fontWeight="bold">{s2Name}</Typography> aims for a higher target margin ({s2Margin.toFixed(2)}%) than <Typography component="span" fontWeight="bold">{s1Name}</Typography> ({s1Margin.toFixed(2)}%).
                                <br />
                                <Typography variant="body2" color="text.secondary">
                                    **Insight:** <Typography component="span" fontWeight="bold">{s2Name}</Typography> is more aggressive on margin percentage, which could indicate a focus on higher profitability per unit sold.
                                </Typography>
                            </Typography>
                        } />
                    </ListItem>
                );
            }
        } // Add more else if blocks for target profit comparison if both use target profit

        // 5. Product Mix/Units Comparison (High-level)
        const s1TotalExpectedUnits = s1.calculatedProducts.reduce((sum, p) => sum + p.expectedUnits, 0);
        const s2TotalExpectedUnits = s2.calculatedProducts.reduce((sum, p) => sum + p.expectedUnits, 0);
        if (s1TotalExpectedUnits > s2TotalExpectedUnits) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s1Name}</Typography> involves a higher total number of expected units ({s1TotalExpectedUnits}) across its products compared to <Typography component="span" fontWeight="bold">{s2Name}</Typography> ({s2TotalExpectedUnits}).
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** <Typography component="span" fontWeight="bold">{s1Name}</Typography> might imply a strategy for higher sales volume. Consider the operational capacity needed for this volume.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        } else if (s2TotalExpectedUnits > s1TotalExpectedUnits) {
            insights.push(
                <ListItem>
                    <ListItemText primary={
                        <Typography>
                            <Typography component="span" fontWeight="bold">{s2Name}</Typography> involves a higher total number of expected units ({s2TotalExpectedUnits}) across its products compared to <Typography component="span" fontWeight="bold">{s1Name}</Typography> ({s1TotalExpectedUnits}).
                            <br />
                            <Typography variant="body2" color="text.secondary">
                                **Insight:** <Typography component="span" fontWeight="bold">{s2Name}</Typography> might imply a strategy for higher sales volume. Consider the operational capacity needed for this volume.
                            </Typography>
                        </Typography>
                    } />
                </ListItem>
            );
        }

        // You can add more insights here, e.g., average unit prices, breakdown of product types, etc.

        if (insights.length === 0) {
            return (
                <Typography color="text.secondary" align="center" mt={3}>
                    No significant differences or specific insights found between the selected snapshots based on current criteria.
                </Typography>
            );
        }

        return (
            <List dense>
                {insights}
            </List>
        );
    };


    return (
        <Box sx={{ p: 2, display: 'flex', flexDirection: 'column', gap: 3, maxWidth: '800px', width: '100%' }}>
            <Box>
                <Typography variant="h6" gutterBottom>Save Current Pricing Snapshot</Typography>
                <TextField
                    label="Snapshot Name"
                    fullWidth
                    value={snapshotName}
                    onChange={(e) => setSnapshotName(e.target.value)}
                    margin="normal"
                    disabled={loading}
                />
                <Button
                    variant="contained"
                    color="primary"
                    startIcon={<SaveIcon />}
                    onClick={handleSaveSnapshot}
                    disabled={loading || !snapshotName.trim()}
                    sx={{ mt: 1 }}
                >
                    Save Snapshot
                </Button>
            </Box>

            <Divider />

            <Box>
                <Typography variant="h6" gutterBottom>Load & Manage Snapshots</Typography>
                <Button
                    variant="outlined"
                    color="primary"
                    startIcon={<FolderOpenIcon />}
                    onClick={() => setOpenLoadDialog(true)}
                    disabled={loading || savedSnapshots.length === 0}
                    sx={{ mt: 1 }}
                >
                    Load Snapshot
                </Button>

                <Dialog open={openLoadDialog} onClose={() => setOpenLoadDialog(false)} fullWidth maxWidth="md">
                    <DialogTitle>Load Snapshot</DialogTitle>
                    <DialogContent>
                        {loading ? (
                            <Box display="flex" justifyContent="center" py={4}><CircularProgress /></Box>
                        ) : savedSnapshots.length === 0 ? (
                            <Typography>No snapshots saved yet.</Typography>
                        ) : (
                            <List>
                                {savedSnapshots.map((snapshot) => (
                                    <ListItem
                                        key={snapshot.id}
                                        divider
                                        secondaryAction={
                                            <IconButton edge="end" aria-label="delete" onClick={() => {
                                                setSnapshotToDelete(snapshot);
                                                setOpenDeleteDialog(true);
                                            }}>
                                                <DeleteIcon color="error" />
                                            </IconButton>
                                        }
                                    >
                                        <ListItemText
                                            primary={snapshot.name}
                                            secondary={`Saved: ${new Date(snapshot.created_at).toLocaleString()}`}
                                        />
                                        <Button
                                            onClick={() => handleLoadSnapshot(snapshot.id)}
                                            variant="outlined"
                                            size="small"
                                            sx={{ mr: 2 }}
                                        >
                                            Load
                                        </Button>
                                    </ListItem>
                                ))}
                            </List>
                        )}
                    </DialogContent>
                    <DialogActions>
                        <Button onClick={() => setOpenLoadDialog(false)}>Cancel</Button>
                    </DialogActions>
                </Dialog>

                <Dialog
                    open={openDeleteDialog}
                    onClose={() => setOpenDeleteDialog(false)}
                    aria-labelledby="alert-dialog-title"
                    aria-describedby="alert-dialog-description"
                >
                    <DialogTitle id="alert-dialog-title">{"Confirm Deletion"}</DialogTitle>
                    <DialogContent>
                        <Typography id="alert-dialog-description">
                            Are you sure you want to delete snapshot "{snapshotToDelete?.name}"? This action cannot be undone.
                        </Typography>
                    </DialogContent>
                    <DialogActions>
                        <Button onClick={() => setOpenDeleteDialog(false)}>Cancel</Button>
                        <Button onClick={handleDeleteSnapshot} color="error" autoFocus>
                            Delete
                        </Button>
                    </DialogActions>
                </Dialog>
            </Box>

            <Divider />

            <Box>
                <Typography variant="h6" gutterBottom>Compare Snapshots</Typography>
                <Grid container spacing={2}>
                    <Grid item xs={12} sm={6}>
                        <TextField
                            select
                            label="Select Snapshot 1"
                            fullWidth
                            value={selectedComparisonSnapshot1Id}
                            onChange={(e) => setSelectedComparisonSnapshot1Id(e.target.value)}
                            SelectProps={{ native: true }}
                            disabled={comparisonLoading}
                        >
                            <option value="">-- Select --</option>
                            {savedSnapshots.map((snapshot) => (
                                <option key={snapshot.id} value={snapshot.id}>
                                    {snapshot.name}
                                </option>
                            ))}
                        </TextField>
                    </Grid>
                    <Grid item xs={12} sm={6}>
                        <TextField
                            select
                            label="Select Snapshot 2"
                            fullWidth
                            value={selectedComparisonSnapshot2Id}
                            onChange={(e) => setSelectedComparisonSnapshot2Id(e.target.value)}
                            SelectProps={{ native: true }}
                            disabled={comparisonLoading}
                        >
                            <option value="">-- Select --</option>
                            {savedSnapshots.map((snapshot) => (
                                <option key={snapshot.id} value={snapshot.id}>
                                    {snapshot.name}
                                </option>
                            ))}
                        </TextField>
                    </Grid>
                </Grid>

                <Box mt={2} textAlign="center">
                    <Button
                        variant="outlined"
                        color="secondary"
                        onClick={clearComparison}
                        disabled={!selectedComparisonSnapshot1Id && !selectedComparisonSnapshot2Id}
                        startIcon={<ClearIcon />}
                    >
                        Clear Comparison
                    </Button>
                </Box>

                {comparisonLoading && (
                    <Box display="flex" justifyContent="center" py={4}>
                        <CircularProgress />
                    </Box>
                )}

                <Grid container spacing={3} sx={{ mt: 3 }}>
                    {renderComparisonColumn("Snapshot 1", comparisonSnapshot1Data, comparisonResults1, selectedComparisonSnapshot1Id)}
                    {renderComparisonColumn("Snapshot 2", comparisonSnapshot2Data, comparisonResults2, selectedComparisonSnapshot2Id)}
                </Grid>

                {(comparisonResults1 && comparisonResults2) && (
                    <Card elevation={2} sx={{ mt: 4, width: '100%' }}>
                        <CardContent>
                            <Typography variant="h6" align="center" gutterBottom>Comparison Insights</Typography>
                            {renderComparisonInsights()}
                        </CardContent>
                    </Card>
                )}
            </Box>
        </Box>
    );
};

export default SnapshotManager;